<?xml version="1.0" encoding="utf-8" ?>

<chapter id="test-doubles">
  <title>测试替身</title>

  <para>
    Gerard Meszaros 在 <xref linkend="Meszaros2007" /> 中介绍了测试替身的概念：
  </para>

  <blockquote>
    <attribution>Gerard Meszaros</attribution>
    <para>
      <indexterm><primary>System Under Test （被测系统）</primary></indexterm>

      有时候对被测系统(SUT)进行测试是很困难的，因为它依赖于其他无法在测试环境中使用的组件。这有可能是因为这些组件不可用，它们不会返回测试所需要的结果，或者执行它们会有不良副作用。在其他情况下，我们的测试策略要求对被测系统的内部行为有更多控制或更多可见性。
    </para>

    <para>
      <indexterm><primary>Depended-On Component （依赖组件）</primary></indexterm>
      <indexterm><primary>Test Double （测试替身）</primary></indexterm>

      如果在编写测试时无法使用（或选择不使用）实际的依赖组件(DOC)，可以用测试替身来代替。测试替身不需要和真正的依赖组件有完全一样的的行为方式；他只需要提供和真正的组件同样的 API 即可，这样被测系统就会以为它是真正的组件！
    </para>
  </blockquote>

  <para>
    PHPUnit 提供的 <literal>getMock($className)</literal> 方法可以在测试中用来自动生成一个对象，它可以充当指定原版类的测试替身。在任何预期使用原始类的实例对象的上下文中都可以使用这个测试对象类来代替。
  </para>

  <para>
    在默认情况下，原始类的所有方法都会被替换为只会返回 <literal>NULL</literal> 山寨实现（其中不会调用原版方法）。使用诸如 <literal>will($this->returnValue())</literal> 之类的方法可以对这些山寨实现在被调用时应当返回什么值做出配置。
  </para>

  <note>
    <title>局限性</title>

    <para>
      请注意，<literal>final</literal>、<literal>private</literal> 和 <literal>static</literal> 方法无法对其进行短连(stub)或模仿(mock)。PHPUnit 的测试替身功能将会忽略它们，并维持它们的原始行为。
    </para>
  </note>

  <note>
    <title>警告</title>

    <para>
        请关注一下这个事实：参数管理方式已经修改过了。在之前的实现中，将会克隆对象的所有参数。这样就无法检查传递给方法的是否是同一个对象。<xref linkend="test-doubles.mock-objects.examples.clone-object-parameters-usecase.php" />展示了新的实现方式在什么情况下会非常有用。<xref linkend="test-doubles.mock-objects.examples.enable-clone-object-parameters.php" />展示了如何切换回之前的行为方式。
    </para>
  </note>

  <section id="test-doubles.stubs">
    <title>短连件(Stub)</title>

    <para>
      <indexterm><primary>Stub</primary></indexterm>

      将对象替换为（可选地）返回配置好的返回值的测试替身的实践方法被称为<emphasis>短连(stubbing)</emphasis>。可以用<emphasis>短连件(stub)</emphasis> 来“替换掉被测系统所依赖的实际组件，这样测试就有了对被测系统的间接输入的控制点。这使得测试能强制安排被测系统的执行路径，否则被测系统可能无法执行”。
    </para>

    <para>
      <indexterm><primary>Fluent Interface （流畅式接口）</primary></indexterm>

      <xref linkend="test-doubles.stubs.examples.StubTest.php" /> 展示了如何对方法的调用进行短连以及如何设定返回值。首先用 <literal>PHPUnit_Framework_TestCase</literal> 类提供的 <literal>getMock()</literal> 方法来建立一个短连件对象，它表面看起来像是 <literal>SomeClass</literal>类（<xref linkend="test-doubles.stubs.examples.SomeClass.php" />）的实例。随后用 PHPUnit 提供的<ulink url="http://martinfowler.com/bliki/FluentInterface.html">流畅式接口</ulink>来指定短连件的行为。本质上，这意味着不需要建立多个临时对象然后再把它们捆到一起。取而代之的是范例中所示的链式方法调用。这使得代码更加易读并更加“流畅”。
    </para>

    <example id="test-doubles.stubs.examples.SomeClass.php">
      <title>需要对其进行短连的类</title>
      <programlisting><![CDATA[<?php
class SomeClass
{
    public function doSomething()
    {
        // 随便做点什么。
    }
}
?>]]></programlisting>
    </example>

    <example id="test-doubles.stubs.examples.StubTest.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnValue()</primary></indexterm>
      <title>对某个方法的调用进行短连，返回固定值</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testStub()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMock('SomeClass');

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnValue('foo'));

        // 现在调用 $stub->doSomething() 将返回 'foo'。
        $this->assertEquals('foo', $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      “在幕后”，当使用了 <literal>getMock()</literal> 方法时， PHPUnit 自动生成了一个新的 PHP 类来实现想要的行为。所生成的测试替身类可以通过 <literal>getMock()</literal> 的可选参数来进行配置。
    </para>

    <itemizedlist>
      <listitem><para>默认情况下，给定类的所有方法都会替换为只会返回 <literal>NULL</literal> 的测试替身，除非用 <literal>will($this->returnValue())</literal> 之类的方法配置了测试替身的返回值。</para></listitem>
      <listitem><para>如果提供了第二个（可选）参数，那么只有名称在数组中的方法会被替换为可配置的测试替身。其他方法的行为不会有所改变。如果以 <literal>NULL</literal> 作为（第二）参数，意味着不会有方法被替换。</para></listitem>
      <listitem><para>第三（可选）参数持有的是传递给原版类的构造函数（默认情况下不会被替换为山寨实现）的参数数组。</para></listitem>
      <listitem><para>第四（可选）参数用于指定生成的测试替身类的类名。</para></listitem>
      <listitem><para>第五（可选）参数可用于禁用对原版类的构造方法的调用。</para></listitem>
      <listitem><para>第六（可选）参数可用于禁用对原版类的克隆构造方法的调用。</para></listitem>
      <listitem><para>第七（可选）参数可用于在测试替身类的生成期间禁用 <literal>__autoload()</literal>。</para></listitem>
    </itemizedlist>

    <para>
      另外，仿件生成器(Mock Builder) API 也可以用来对生成的测试替身类进行配置。<xref linkend="test-doubles.stubs.examples.StubTest2.php"/>展示了一个例子。下面列出了可以在仿件生成器的流畅式接口中使用的方法：
    </para>

    <itemizedlist>
      <listitem><para><literal>setMethods(array $methods)</literal> 可以在仿件生成器对象上调用，来指定哪些方法将被替换为可配置的测试提升。其他方法的行为不会有所改变。如果调用 <literal>setMethods(NULL)</literal>，那么没有方法会被替换。</para></listitem>
      <listitem><para><literal>setConstructorArgs(array $args)</literal> 可用于提供传递给原版类的构造函数（默认情况下不会被替换为山寨实现）的参数数组。</para></listitem>
      <listitem><para><literal>setMockClassName($name)</literal> 可用于指定生成的测试替身类的类名。</para></listitem>
      <listitem><para><literal>disableOriginalConstructor()</literal> 参数可用于禁用对原版类的构造方法的调用。</para></listitem>
      <listitem><para><literal>disableOriginalClone()</literal> 可用于禁用对原版类的克隆构造方法的调用。</para></listitem>
      <listitem><para><literal>disableAutoload()</literal> 可用于在测试替身类的生成期间禁用 <literal>__autoload()</literal>。</para></listitem>
    </itemizedlist>

    <example id="test-doubles.stubs.examples.StubTest2.php">
      <indexterm><primary>getMockBuilder()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnValue()</primary></indexterm>
      <title>使用可用于配置生成的测试替身类的仿件生成器 API</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testStub()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMockBuilder('SomeClass')
                     ->disableOriginalConstructor()
                     ->getMock();

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnValue('foo'));

        //  现在调用 $stub->doSomething() 将返回 'foo'。
        $this->assertEquals('foo', $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      有时想要将（未改变的）方法调用时所使用的参数之一作为短连的方法的调用结果来返回。<xref linkend="test-doubles.stubs.examples.StubTest3.php"/>展示了如何用 <literal>returnArgument()</literal> 代替 <literal>returnValue()</literal> 来做到这点。
    </para>

    <example id="test-doubles.stubs.examples.StubTest3.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnArgument()</primary></indexterm>
      <title>对某个方法的调用进行短连，返回参数之一</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnArgumentStub()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMock('SomeClass');

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnArgument(0));

        // $stub->doSomething('foo') 返回 'foo'
        $this->assertEquals('foo', $stub->doSomething('foo'));

        // $stub->doSomething('bar') 返回 'bar'
        $this->assertEquals('bar', $stub->doSomething('bar'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      在对流畅式接口进行测试时，让某个短连的方法返回对短连件对象的引用有时会很有用。<xref linkend="test-doubles.stubs.examples.StubTest4.php"/> 展示了如何用 <literal>returnSelf()</literal> 来做到这点。
    </para>

    <example id="test-doubles.stubs.examples.StubTest4.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnSelf()</primary></indexterm>
      <title>对方法的调用进行短连，返回对短连件对象的引用</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnSelf()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMock('SomeClass');

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnSelf());

        // $stub->doSomething() 返回 $stub
        $this->assertSame($stub, $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      有时候，短连的方法需要根据预定义的参数清单来返回不同的值。可以用 <literal>returnValueMap()</literal> 方法将参数和相应的返回值关联起来建立映射。范例参见<xref linkend="test-doubles.stubs.examples.StubTest5.php"/>。
    </para>

    <example id="test-doubles.stubs.examples.StubTest5.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnValueMap()</primary></indexterm>
      <title>对方法的调用进行短连，按照映射确定返回值</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnValueMapStub()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMock('SomeClass');

        // 创建从参数到返回值的映射。
        $map = array(
          array('a', 'b', 'c', 'd'),
          array('e', 'f', 'g', 'h')
        );

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnValueMap($map));

        // $stub->doSomething() 根据提供的参数返回不同的值。
        $this->assertEquals('d', $stub->doSomething('a', 'b', 'c'));
        $this->assertEquals('h', $stub->doSomething('e', 'f', 'g'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      如果短连的方法需要返回计算得到的值而不是固定值（参见 <literal>returnValue()</literal>）或某个（未改变的）参数（参见 <literal>returnArgument()</literal>），可以用 <literal>returnCallback()</literal> 来让短连的方法返回回调函数或方法的结果。范例参见 <xref linkend="test-doubles.stubs.examples.StubTest6.php"/>。
    </para>

    <example id="test-doubles.stubs.examples.StubTest6.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnCallback()</primary></indexterm>
      <title>对方法的调用进行短连，由回调生成返回值</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnCallbackStub()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMock('SomeClass');

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnCallback('str_rot13'));

        // $stub->doSomething($argument) 返回 str_rot13($argument)
        $this->assertEquals('fbzrguvat', $stub->doSomething('something'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      相比于建立回调方法，有一个更简单的选择是直接给出期望返回值的列表。可以用 <literal>onConsecutiveCalls()</literal> 方法来做到这个。范例参见 <xref linkend="test-doubles.stubs.examples.StubTest7.php"/>。
    </para>

    <example id="test-doubles.stubs.examples.StubTest7.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>onConsecutiveCalls()</primary></indexterm>
      <title>对方法的调用进行短连，按照指定顺序返回列表中的值</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testOnConsecutiveCallsStub()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMock('SomeClass');

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->onConsecutiveCalls(2, 3, 5, 7));

        // $stub->doSomething() 每次返回值都不同
        $this->assertEquals(2, $stub->doSomething());
        $this->assertEquals(3, $stub->doSomething());
        $this->assertEquals(5, $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>


    <para>
      除了返回一个值之外，短连的方法还能抛出一个异常。<xref linkend="test-doubles.stubs.examples.StubTest8.php"/>展示了如何用 <literal>throwException()</literal> 做到这点。
    </para>

    <example id="test-doubles.stubs.examples.StubTest8.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>throwException()</primary></indexterm>
      <title>对方法的调用进行短连，抛出异常</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testThrowExceptionStub()
    {
        // 为 SomeClass 类创建短连件。
        $stub = $this->getMock('SomeClass');

        // 配置短连件。
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->throwException(new Exception));

        // $stub->doSomething() 抛出异常
        $stub->doSomething();
    }
}
?>]]></programlisting>
    </example>

    <para>
      Alternatively, you can write the stub yourself and improve your design
      along the way. Widely used resources are accessed through a single façade,
      so you can easily replace the resource with the stub. For example,
      instead of having direct database calls scattered throughout the code,
      you have a single <literal>Database</literal> object, an implementor of
      the <literal>IDatabase</literal> interface. Then, you can create a stub
      implementation of <literal>IDatabase</literal> and use it for your
      tests. You can even create an option for running the tests with the
      stub database or the real database, so you can use your tests for both
      local testing during development and integration testing with the real
      database.
    </para>

    <para>
      Functionality that needs to be stubbed out tends to cluster in the same
      object, improving cohesion. By presenting the functionality with a
      single, coherent interface you reduce the coupling with the rest of the
      system.
    </para>
  </section>

  <section id="test-doubles.mock-objects">
    <title>仿件对象(Mock Object)</title>

    <para>
      The practice of replacing an object with a test double that verifies
      expectations, for instance asserting that a method has been called, is
      refered to as <emphasis>mocking</emphasis>.
    </para>

    <para>
      <indexterm><primary>Mock Object</primary></indexterm>

      You can use a <emphasis>mock object</emphasis> "as an observation point
      that is used to verify the indirect outputs of the SUT as it is exercised.
      Typically, the mock object also includes the functionality of a test stub
      in that it must return values to the SUT if it hasn't already failed the
      tests but the emphasis is on the verification of the indirect outputs.
      Therefore, a mock object is lot more than just a test stub plus
      assertions; it is used a fundamentally different way".
    </para>

    <para>
      Here is an example: suppose we want to test that the correct method,
      <literal>update()</literal> in our example, is called on an object that
      observes another object. <xref linkend="test-doubles.mock-objects.examples.SUT.php"/>
      shows the code for the <literal>Subject</literal> and <literal>Observer</literal>
      classes that are part of the System under Test (SUT).
    </para>

    <example id="test-doubles.mock-objects.examples.SUT.php">
      <title>The Subject and Observer classes that are part of the System under Test (SUT)</title>
      <programlisting><![CDATA[<?php
class Subject
{
    protected $observers = array();

    public function attach(Observer $observer)
    {
        $this->observers[] = $observer;
    }

    public function doSomething()
    {
        // Do something.
        // ...

        // Notify observers that we did something.
        $this->notify('something');
    }

    public function doSomethingBad()
    {
        foreach ($this->observers as $observer) {
            $observer->reportError(42, 'Something bad happened', $this);
        }
    }

    protected function notify($argument)
    {
        foreach ($this->observers as $observer) {
            $observer->update($argument);
        }
    }

    // Other methods.
}

class Observer
{
    public function update($argument)
    {
        // Do something.
    }

    public function reportError($errorCode, $errorMessage, Subject $subject)
    {
        // Do something
    }

    // Other methods.
}
?>]]></programlisting>
    </example>

    <para>
      <indexterm><primary>Mock Object</primary></indexterm>

      <xref linkend="test-doubles.mock-objects.examples.SubjectTest.php" />
      shows how to use a mock object to test the interaction between
      <literal>Subject</literal> and <literal>Observer</literal> objects.
    </para>

    <para>
      We first use the <literal>getMock()</literal> method that is provided by
      the <literal>PHPUnit_Framework_TestCase</literal> class to set up a mock
      object for the <literal>Observer</literal>. Since we give an array as the
      second (optional) parameter for the <literal>getMock()</literal> method,
      only the <literal>update()</literal> method of the
      <literal>Observer</literal> class is replaced by a mock implementation.
    </para>

    <example id="test-doubles.mock-objects.examples.SubjectTest.php">
      <title>Testing that a method gets called once and with a specified argument</title>
      <programlisting><![CDATA[<?php
class SubjectTest extends PHPUnit_Framework_TestCase
{
    public function testObserversAreUpdated()
    {
        // Create a mock for the Observer class,
        // only mock the update() method.
        $observer = $this->getMock('Observer', array('update'));

        // Set up the expectation for the update() method
        // to be called only once and with the string 'something'
        // as its parameter.
        $observer->expects($this->once())
                 ->method('update')
                 ->with($this->equalTo('something'));

        // Create a Subject object and attach the mocked
        // Observer object to it.
        $subject = new Subject;
        $subject->attach($observer);

        // Call the doSomething() method on the $subject object
        // which we expect to call the mocked Observer object's
        // update() method with the string 'something'.
        $subject->doSomething();
    }
}
?>]]></programlisting>
    </example>

    <para>
      The <literal>with()</literal> method can take any number of
      arguments, corresponding to the number of parameters to the
      method being mocked. You can specify more advanced constraints
      on the method argument than a simple match.
    </para>

    <example id="test-doubles.mock-objects.examples.MultiParameterTest.php">
      <title>Testing that a method gets called with a number of
      arguments constrained in different ways</title>
      <programlisting><![CDATA[<?php
class SubjectTest extends PHPUnit_Framework_TestCase
{
    public function testErrorReported()
    {
        // Create a mock for the Observer class, mocking the
        // reportError() method
        $observer = $this->getMock('Observer', array('reportError'));

        $observer->expects($this->once())
                 ->method('reportError')
                 ->with($this->greaterThan(0),
                        $this->stringContains('Something'),
                        $this->anything());

        $subject = new Subject;
        $subject->attach($observer);

        // The doSomethingBad() method should report an error to the observer
        // via the reportError() method
        $subject->doSomethingBad();
    }
}
?>]]></programlisting>
    </example>

    <example id="test-doubles.mock-objects.examples.clone-object-parameters-usecase.php">
      <title>Testing that a method gets called once and with the identical object as was passed</title>
      <programlisting><![CDATA[<?php
class FooTest extends PHPUnit_Framework_TestCase
{
    public function testIdenticalObjectPassed()
    {
        $expectedObject = new stdClass;

        $mock = $this->getMock('stdClass', array('foo'));
        $mock->expects($this->once())
             ->method('foo')
             ->with($this->identicalTo($expectedObject));

        $mock->foo($expectedObject);
    }
}
?>]]></programlisting>
    </example>

    <example id="test-doubles.mock-objects.examples.enable-clone-object-parameters.php">
      <title>Create a mock object with cloning parameters enabled</title>
      <programlisting><![CDATA[<?php
class FooTest extends PHPUnit_Framework_TestCase
{
    public function testIdenticalObjectPassed()
    {
        $cloneArguments = true;

        $mock = $this->getMock(
            'stdClass',
            array(),
            array(),
            '',
            FALSE,
            TRUE,
            TRUE,
            $cloneArguments
        );

        // or using the mock builder
        $mock = $this->getMockBuilder('stdClass')
                     ->enableArgumentCloning()
                     ->getMock();

        // now your mock clones parameters so the identicalTo constraint
        // will fail.
    }
}
?>]]></programlisting>
    </example>

    <para>
      <xref linkend="writing-tests-for-phpunit.assertions.assertThat.tables.constraints"/>
      shows the constraints that can be applied to method arguments and
      <xref linkend="test-doubles.mock-objects.tables.matchers"/>
      shows the matchers that are available to specify the number of
      invocations.
    </para>

    <table id="test-doubles.mock-objects.tables.matchers">
      <title>Matchers</title>

      <tgroup cols="2" align="left" colsep="1" rowsep="1">
        <thead>
          <row>
            <entry>Matcher</entry>
            <entry>Meaning</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_AnyInvokedCount any()</literal></entry>
            <entry>Returns a matcher that matches when the method it is evaluated for is executed zero or more times.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount never()</literal></entry>
            <entry>Returns a matcher that matches when the method it is evaluated for is never executed.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedAtLeastOnce atLeastOnce()</literal></entry>
            <entry>Returns a matcher that matches when the method it is evaluated for is executed at least once.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount once()</literal></entry>
            <entry>Returns a matcher that matches when the method it is evaluated for is executed exactly once.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount exactly(int $count)</literal></entry>
            <entry>Returns a matcher that matches when the method it is evaluated for is executed exactly <literal>$count</literal> times.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedAtIndex at(int $index)</literal></entry>
            <entry>Returns a matcher that matches when the method it is evaluated for is invoked at the given <literal>$index</literal>.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section id="test-doubles.mocking-traits-and-abstract-classes">
    <title>Mocking Traits and Abstract Classes</title>

    <para>
      <indexterm><primary>getMockForTrait()</primary></indexterm>

      The <literal>getMockForTrait()</literal> method returns a mock object
      that uses a specified trait. All abstract methods of the given trait
      are mocked. This allows for testing the concrete methods of a trait.
    </para>

    <example id="test-doubles.mock-objects.examples.TraitClassTest.php">
      <title>Testing the concrete methods of a trait</title>
      <programlisting><![CDATA[<?php
trait AbstractTrait
{
    public function concreteMethod()
    {
        return $this->abstractMethod();
    }

    public abstract function abstractMethod();
}

class TraitClassTest extends PHPUnit_Framework_TestCase
{
    public function testConcreteMethod()
    {
        $mock = $this->getMockForTrait('AbstractTrait');
        $mock->expects($this->any())
             ->method('abstractMethod')
             ->will($this->returnValue(TRUE));

        $this->assertTrue($mock->concreteMethod());
    }
}
?>]]></programlisting>
    </example>

    <para>
      <indexterm><primary>getMockForAbstractClass()</primary></indexterm>

      The <literal>getMockForAbstractClass()</literal> method returns a mock
      object for an abstract class. All abstract methods of the given abstract
      class are mocked. This allows for testing the concrete methods of an
      abstract class.
    </para>

    <example id="test-doubles.mock-objects.examples.AbstractClassTest.php">
      <title>Testing the concrete methods of an abstract class</title>
      <programlisting><![CDATA[<?php
abstract class AbstractClass
{
    public function concreteMethod()
    {
        return $this->abstractMethod();
    }

    public abstract function abstractMethod();
}

class AbstractClassTest extends PHPUnit_Framework_TestCase
{
    public function testConcreteMethod()
    {
        $stub = $this->getMockForAbstractClass('AbstractClass');
        $stub->expects($this->any())
             ->method('abstractMethod')
             ->will($this->returnValue(TRUE));

        $this->assertTrue($stub->concreteMethod());
    }
}
?>]]></programlisting>
    </example>
  </section>

  <section id="test-doubles.stubbing-and-mocking-web-services">
    <title>Stubbing and Mocking Web Services</title>

    <para>
      <indexterm><primary>getMockFromWsdl()</primary></indexterm>

      When your application interacts with a web service you want to test it
      without actually interacting with the web service. To make the stubbing
      and mocking of web services easy, the <literal>getMockFromWsdl()</literal>
      can be used just like <literal>getMock()</literal> (see above). The only
      difference is that <literal>getMockFromWsdl()</literal> returns a stub or
      mock based on a web service description in WSDL and <literal>getMock()</literal>
      returns a stub or mock based on a PHP class or interface.
    </para>

    <para>
      <xref linkend="test-doubles.stubbing-and-mocking-web-services.examples.GoogleTest.php"/>
      shows how <literal>getMockFromWsdl()</literal> can be used to stub, for
      example, the web service described in <filename>GoogleSearch.wsdl</filename>.
    </para>

    <example id="test-doubles.stubbing-and-mocking-web-services.examples.GoogleTest.php">
      <title>Stubbing a web service</title>
      <programlisting><![CDATA[<?php
class GoogleTest extends PHPUnit_Framework_TestCase
{
    public function testSearch()
    {
        $googleSearch = $this->getMockFromWsdl(
          'GoogleSearch.wsdl', 'GoogleSearch'
        );

        $directoryCategory = new StdClass;
        $directoryCategory->fullViewableName = '';
        $directoryCategory->specialEncoding = '';

        $element = new StdClass;
        $element->summary = '';
        $element->URL = 'http://www.phpunit.de/';
        $element->snippet = '...';
        $element->title = '<b>PHPUnit</b>';
        $element->cachedSize = '11k';
        $element->relatedInformationPresent = TRUE;
        $element->hostName = 'www.phpunit.de';
        $element->directoryCategory = $directoryCategory;
        $element->directoryTitle = '';

        $result = new StdClass;
        $result->documentFiltering = FALSE;
        $result->searchComments = '';
        $result->estimatedTotalResultsCount = 378000;
        $result->estimateIsExact = FALSE;
        $result->resultElements = array($element);
        $result->searchQuery = 'PHPUnit';
        $result->startIndex = 1;
        $result->endIndex = 1;
        $result->searchTips = '';
        $result->directoryCategories = array();
        $result->searchTime = 0.248822;

        $googleSearch->expects($this->any())
                     ->method('doGoogleSearch')
                     ->will($this->returnValue($result));

        /**
         * $googleSearch->doGoogleSearch() will now return a stubbed result and
         * the web service's doGoogleSearch() method will not be invoked.
         */
        $this->assertEquals(
          $result,
          $googleSearch->doGoogleSearch(
            '00000000000000000000000000000000',
            'PHPUnit',
            0,
            1,
            FALSE,
            '',
            FALSE,
            '',
            '',
            ''
          )
        );
    }
}
?>]]></programlisting>
    </example>
  </section>

  <section id="test-doubles.mocking-the-filesystem">
    <title>Mocking the Filesystem</title>

    <para>
      <ulink url="https://github.com/mikey179/vfsStream">vfsStream</ulink>
      is a <ulink url="http://www.php.net/streams">stream wrapper</ulink> for a
      <ulink url="http://en.wikipedia.org/wiki/Virtual_file_system">virtual
      filesystem</ulink> that may be helpful in unit tests to mock the real
      filesystem.
    </para>

    <para>
      To install vfsStream, the PEAR channel
      (<systemitem role="URL">pear.bovigo.org</systemitem>) that is used for
      its distribution needs to be registered with the local PEAR environment:
    </para>

    <screen><userinput>pear channel-discover pear.bovigo.org</userinput></screen>

    <para>
      This has to be done only once. Now the PEAR Installer can be used to
      install vfsStream:
    </para>

    <screen><userinput>pear install bovigo/vfsStream-beta</userinput></screen>

    <para>
      <xref linkend="test-doubles.mocking-the-filesystem.examples.Example.php"/>
      shows a class that interacts with the filesystem.
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.Example.php">
      <title>A class that interacts with the filesystem</title>
      <programlisting><![CDATA[<?php
class Example
{
    protected $id;
    protected $directory;

    public function __construct($id)
    {
        $this->id = $id;
    }

    public function setDirectory($directory)
    {
        $this->directory = $directory . DIRECTORY_SEPARATOR . $this->id;

        if (!file_exists($this->directory)) {
            mkdir($this->directory, 0700, TRUE);
        }
    }
}?>]]></programlisting>
    </example>

    <para>
      Without a virtual filesystem such as vfsStream we cannot test the
      <literal>setDirectory()</literal> method in isolation from external
      influence (see <xref
      linkend="test-doubles.mocking-the-filesystem.examples.ExampleTest.php"/>).
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.ExampleTest.php">
      <title>Testing a class that interacts with the filesystem</title>
      <programlisting><![CDATA[<?php
require_once 'Example.php';

class ExampleTest extends PHPUnit_Framework_TestCase
{
    protected function setUp()
    {
        if (file_exists(dirname(__FILE__) . '/id')) {
            rmdir(dirname(__FILE__) . '/id');
        }
    }

    public function testDirectoryIsCreated()
    {
        $example = new Example('id');
        $this->assertFalse(file_exists(dirname(__FILE__) . '/id'));

        $example->setDirectory(dirname(__FILE__));
        $this->assertTrue(file_exists(dirname(__FILE__) . '/id'));
    }

    protected function tearDown()
    {
        if (file_exists(dirname(__FILE__) . '/id')) {
            rmdir(dirname(__FILE__) . '/id');
        }
    }
}
?>]]></programlisting>
    </example>

    <para>
      The approach above has several drawbacks:
    </para>

    <itemizedlist>
      <listitem><para>As with any external resource, there might be intermittent problems with the filesystem. This makes tests interacting with it flaky.</para></listitem>
      <listitem><para>In the <literal>setUp()</literal> and <literal>tearDown()</literal> methods we have to ensure that the directory does not exist before and after the test.</para></listitem>
      <listitem><para>When the test execution terminates before the <literal>tearDown()</literal> method is invoked the directory will stay in the filesystem.</para></listitem>
    </itemizedlist>

    <para>
      <xref linkend="test-doubles.mocking-the-filesystem.examples.ExampleTest2.php"/>
      shows how vfsStream can be used to mock the filesystem in a test for a
      class that interacts with the filesystem.
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.ExampleTest2.php">
      <title>Mocking the filesystem in a test for a class that interacts with the filesystem</title>
      <programlisting><![CDATA[<?php
require_once 'vfsStream/vfsStream.php';
require_once 'Example.php';

class ExampleTest extends PHPUnit_Framework_TestCase
{
    public function setUp()
    {
        vfsStreamWrapper::register();
        vfsStreamWrapper::setRoot(new vfsStreamDirectory('exampleDir'));
    }

    public function testDirectoryIsCreated()
    {
        $example = new Example('id');
        $this->assertFalse(vfsStreamWrapper::getRoot()->hasChild('id'));

        $example->setDirectory(vfsStream::url('exampleDir'));
        $this->assertTrue(vfsStreamWrapper::getRoot()->hasChild('id'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      This has several advantages:
    </para>

    <itemizedlist>
      <listitem><para>The test itself is more concise.</para></listitem>
      <listitem><para>vfsStream gives the test developer full control over what the filesystem environment looks like to the tested code.</para></listitem>
      <listitem><para>Since the filesystem operations do not operate on the real filesystem anymore, cleanup operations in a <literal>tearDown()</literal> method are no longer required.</para></listitem>
    </itemizedlist>
  </section>
</chapter>
