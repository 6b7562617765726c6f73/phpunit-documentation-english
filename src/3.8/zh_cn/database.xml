<?xml version="1.0" encoding="utf-8" ?>

<chapter id="database">
  <title>数据库测试</title>
  <para>
    在各种编程语言中，许多入门或者中级的单元测试范例都暗示了这样一种信息：用简单的测试来对应用程序的逻辑进行测试是极其容易的。但是对于以数据库为中心的应用程序而言，这与现实相去甚远。一旦开始在诸如 Wordpress、 TYPO3、或 Symfony 中使用 Doctrine 或者 Propel 之类的组件，很容易在 使用 PHPUnit 时经历数量可观的问题：正是由于这些库和数据库之间实在耦合的太紧密了。
  </para>
  <para>
    你可能从日常工作或者项目中得到对这种情况的认知，正当打算在工作中运用你那或生疏或纯熟的 PHPUnit 技能时，你被以下问题之一卡住了：
  </para>
  <orderedlist numeration="arabic">
    <listitem>
      <para>
        待测方法执行了一个相当大的JOIN操作，并使用这些数据计算出了一些重要的结果。
      </para>
    </listitem>
    <listitem>
      <para>
        业务逻辑中混合执行了 SELECT、INSERT、UPDATE 和 DELETE 语句。
      </para>
    </listitem>
    <listitem>
      <para>
        为了给待测方法建立合理的初始数据，需要在两个以上（可能远超过）表里设置测试数据。
      </para>
    </listitem>
  </orderedlist>
  <para>
    DbUnit 扩展大大简化了为测试目的设置数据库的操作，并且允许在对数据执行了一系列操作之后验证数据库的内容。可以像这样安装它：
  </para>
  <screen><userinput>pear install phpunit/DbUnit</userinput></screen>
  <section id="supported-vendors-for-database-testing">
    <title>数据库测试所支持的供应商</title>
    <para>
      DbUnit 目前支持 MySQL、PostgreSQL、Oracle 和 SQLite。通过集成 <ulink url="http://framework.zend.com">Zend Framework</ulink> 或者 <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink>，可以访问其他数据库系统，比如 IBM DB2 或者 Microsoft SQL Server。
    </para>
  </section>
  <section id="difficulties-in-database-testing">
    <title>数据库测试中的难点</title>
    <para>
      关于为什么所有单元测试的范例都不包含数据库交互，这里有个很好的理由：这类测试的建立和维护都很复杂。对数据库进行测试时，需要处理以下可变因素：
    </para>
    <itemizedlist>
      <listitem>
        <para>
          数据库和表
        </para>
      </listitem>
      <listitem>
        <para>
          向表中插入测试所需要的行
        </para>
      </listitem>
      <listitem>
        <para>
          测试运行完毕后验证数据库的状态
        </para>
      </listitem>
      <listitem>
        <para>
          每个新测试都要清理数据库
        </para>
      </listitem>
    </itemizedlist>
    <para>
      许多数据库 API，比如 PDO、MySQLi 或者 OCI8，都十分繁琐且书写起来十分冗长，因此，手工进行这些步骤绝对是噩梦。
    </para>
    <para>
      测试代码应当尽可能简短精确，这有若干原因：
    </para>
    <itemizedlist>
      <listitem>
        <para>
          你不希望为生产代码的小变更而对测试代码进行数量可观的修改。
        </para>
      </listitem>
      <listitem>
        <para>
          你希望在哪怕好几个月以后也能轻松地阅读并理解测试代码。
        </para>
      </listitem>
    </itemizedlist>
    <para>
      另外，必须认识到，对于代码而言，本质上来说数据库是全局输入变量。测试套件中的两个不同的测试可以使用同一个数据库，并且可能把数据重用好多次。一个测试中的失败很容易影响到后继测试的结果，从而让测试经历变得非常艰难。前面提到的清理步骤对于解决<quote>数据库是全局输入</quote>的问题是非常重要的。
    </para>
    <para>
      DbUnit 以一种优雅的方式来帮助简化数据库测试中的所有这些问题。
    </para>
    <para>
      PHPUnit 无法帮你解决的问题是，相对于不使用数据的测试而言数据库测试是非常慢的。随着数据库交互规模的增大，测试可能需要运行可观的时间。然而，只要保持每个测试所使用的数据量较小并且尽可能使用非数据库测试来对代码进行测试，即使很大的测试套件也能轻松在一分钟内跑完。
    </para>
    <para>
      以 <ulink url="http://www.doctrine-project.org">Doctrine 2 </ulink> 为例，此项目的测试套件目前包含了大约1000个测试，其中将近一半访问了数据库，但是在一台安装了MySQL的普通的台式机上，整个测试套件依然能在15秒钟内跑完。
    </para>
  </section>
  <section id="the-four-stages-of-a-database-test">
    <title>数据库测试的四个阶段</title>
    <para>
      Gerard Meszaros 在他的书《xUnit 测试模式》中列出了单元测试的四个阶段：
    </para>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          建立基境(Setup)
        </para>
      </listitem>
      <listitem>
        <para>
          执行被测系统(Exercise)
        </para>
      </listitem>
      <listitem>
        <para>
          验证结果(Verify)
        </para>
      </listitem>
      <listitem>
        <para>
          拆除基境(Teardown)
        </para>
      </listitem>
    </orderedlist>
    <blockquote>
      <para>
        <emphasis role="strong">什么是基境？</emphasis>
      </para>
      <para>
        基境是对开始执行某个测试时应用程序和数据库的初始状态的描述。
      </para>
    </blockquote>
    <para>
      对数据库进行测试至少要处理建立与拆除的步骤，在其中完成清理工作，并将所需的基境数据写入表内。然而对于数据库扩展模块而言，在数据库测试中有很好的理由将这四个步骤还原成像下面这样的工作流程，这个流程对于每个测试都会完整执行：
    </para>
    <section id="clean-up-database">
      <title>1. 清理数据库</title>
      <para>
        由于总是会有某个测试运行在并不确定表中是否有数据的数据库上，PHPUnit 在所有指定表上执行 TRUNCATE 操作来把它们清空。
      </para>
    </section>
    <section id="set-up-fixture">
      <title>2. 建立基境</title>
      <para>
        PHPUnit 随后将迭代所有指定的基境数据行并将其插入到对应的表里。
      </para>
    </section>
    <section id="run-test-verify-outcome-and-teardown">
      <title>3–5. 运行测试、验证结果、并拆除基境</title>
      <para>
        PHPUnit 在所有数据库都完成重置并加载好初始状态后执行实际测试。这个部分的测试代码完全不需要数据库扩展模块的参与，可以随意测试任何你想测试的内容。
      </para>
      <para>
        在测试中使用一个名为 <literal>assertDataSetsEqual()</literal> 的特殊断言来实现验证的目的。当然，这个完全是可选的。这个特性将在<quote>数据库断言</quote>一节中进行解说。
      </para>
    </section>
  </section>
  <section id="configuration-of-a-phpunit-database-testcase">
    <title>PHPUnit 数据库测试用例的配置</title>
    <para>
      一般在使用 PHPUnit 的时候测试用例都是按如下方式扩展自 <literal>PHPUnit_Framework_TestCase</literal> 类的：
    </para>
    <screen>
require_once &quot;PHPUnit/Framework/TestCase.php&quot;;

class MyTest extends PHPUnit_Framework_TestCase
{
    public function testCalculate()
    {
        $this-&gt;assertEquals(2, 1 + 1);
    }
}
</screen>
    <para>
      如果测试代码用到了数据库扩展模块，那么建立的过程就会更复杂一些，需要扩展另外一个抽象 TestCase 类，它要求实现两个抽象方法，<literal>getConnection()</literal> 和 <literal>getDataSet()</literal>：
    </para>
    <screen>
require_once &quot;PHPUnit/Extensions/Database/TestCase.php&quot;;

class MyGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this-&gt;createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this-&gt;createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
</screen>
    <section id="implementing-getconnection">
      <title>实现 getConnection()</title>
      <para>
        为了让清理与载入基境的功能能正常运作，PHPUnit 数据库扩展模块需要用 PDO 库来对数据库进行跨供应商的抽象连接与访问。重要的是要注意到，使用 PHPUnit 的数据库扩展模块并不要求应用程序本身基于PDO，PDO连接仅仅用于清理和建立基境。
      </para>
      <para>
        在之前的例子里，我们建立了一个在内存中的 Sqlite 连接，并将其传递给 <literal>createDefaultDBConnection</literal> 方法，这个方法将 PDO 实例和第二个参数（数据库名）包装在一个非常简单的数据库连接抽象层中，这个抽象层的类型是 <literal>PHPUnit_Extensions_Database_DB_IDatabaseConnection</literal>。
      </para>
      <para>
        <quote>使用数据库连接</quote>一节解说了这个接口的API以及如何充分利用它们。
      </para>
    </section>
    <section id="implementing-getdataset">
      <title>实现 getDataSet()</title>
      <para>
        <literal>getDataSet()</literal> 方法定义了在每个测试执行之前的数据库初始状态应该是什么样。数据库的状态通过由 <literal>PHPUnit_Extensions_Database_DataSet_IDataSet</literal> 所代表的 DataSet 和 由 <literal>PHPUnit_Extensions_Database_DataSet_IDataTable</literal> 所代表的 DataTable 这两个概念进行抽象。下一节将详细讲述这些概念是如何运作的以及在数据库测试中使用它们有什么好处。
      </para>
      <para>
        对于具体实现，只需要知道 <literal>setUp()</literal> 中会调用一次 <literal>getDataSet()</literal> 方法来接收基境数据集并将其插入数据库。在范例中使用了工厂方法 <literal>createFlatXMLDataSet($filename)</literal>，它代表了一个用 XML 表示的数据集。
      </para>
    </section>
    <section id="what-about-the-database-schema-ddl">
      <title>有关数据库构架(DDL)？</title>
      <para>
        PHPUnit 假设在测试运行之前，数据库以及其中的所有表、触发器(trigger)、序列(Sequence)和视图(view)都已经创建好。这意味着开发者必须在运行测试套件之前确保数据库已经正确设置。
      </para>
      <para>
        有几种方法来达成这个数据库测试的先决条件。
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            如果使用的是持久化数据库(不是 Sqlite Memory)，可以很轻松地用 phpMyAdmin（针对MySQL）之类的工具来一次性建立数据库，并在每个测试中复用这个数据库。
          </para>
        </listitem>
        <listitem>
          <para>
            如果使用的是诸如 <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> 或者 <ulink url="http://www.propelorm.org/">Propel</ulink> 这样的库，可以用它们的API来在测试运行前一次性建立所需的数据库。可以利用 <ulink url="http://www.phpunit.de/manual/current/en/textui.html">PHPUnit 的引导和配置</ulink>功能来在每次测试运行时执行这些代码。
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="tip-use-your-own-abstract-database-testcase">
      <title>小建议：使用你自己的抽象数据库 TestCase 类</title>
      <para>
        从前面的实现范例中可以看出，<literal>getConnection()</literal> 方法是相当稳定的，可以在不同的数据库测试用例中重用。另外，为了保持测试的性能良好和数据库的开销较低，可以对代码进行一点重构，来为应用程序形成一个通用的抽象 TestCase 类，并且依然可以为每个测试用例指定不同的数据基境：
      </para>
      <screen>
require_once &quot;PHPUnit/Extensions/Database/TestCase.php&quot;;

abstract class MyApp_Tests_DatabaseTestCase extends PHPUnit_Extensions_Database_TestCase
{
    // 只实例化 pdo 一次，供测试的清理和基境读取使用。
    static private $pdo = null;

    // 对于每个测试，只实例化 PHPUnit_Extensions_Database_DB_IDatabaseConnection 一次。
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this-&gt;conn;
    }
}
</screen>
      <para>
        这个例子里，数据库连接信息硬编码在 PDO 连接里了。PHPUnit 有另外一个绝妙的特性，可以让这个 TestCase 类更加通用。如果用了 <ulink url="http://www.phpunit.de/manual/current/en/appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables">XML 配置</ulink>，就可以为每个测试单独配置数据库连接信息。首先，在应用程序的 tests/ 目录下创建 <quote>phpunit.xml</quote> 文件，内容大体是这样：
      </para>
      <screen>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;phpunit&gt;
    &lt;php&gt;
        &lt;var name=&quot;DB_DSN&quot; value=&quot;mysql:dbname=myguestbook;host=localhost&quot; /&gt;
        &lt;var name=&quot;DB_USER&quot; value=&quot;user&quot; /&gt;
        &lt;var name=&quot;DB_PASSWD&quot; value=&quot;passwd&quot; /&gt;
        &lt;var name=&quot;DB_DBNAME&quot; value=&quot;myguestbook&quot; /&gt;
    &lt;/php&gt;
&lt;/phpunit&gt;
</screen>
      <para>
        现在可以修改 TestCase 类了，像这样：
      </para>
      <screen>
abstract class Generic_Tests_DatabaseTestCase extends PHPUnit_Extensions_Database_TestCase
{
    // 只实例化 pdo 一次，供测试的清理和基境读取使用。
    static private $pdo = null;

    // 对于每个测试，只实例化 PHPUnit_Extensions_Database_DB_IDatabaseConnection 一次。
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this-&gt;conn;
    }
}
</screen>
      <para>
        现在可以从命令行界面以不同的配置来运行数据库测试套件了：
      </para>
      <screen>
user@desktop&gt; phpunit --configuration developer-a.xml MyTests/
user@desktop&gt; phpunit --configuration developer-b.xml MyTests/
</screen>
      <para>
        如果是在开发机上进行开发，能够轻松的针对不同的目标数据库来运行数据库测试就显得非常重要了。如果多个开发人员针对同一个数据库连接运行数据库测试，很容易因为竞态而导致测试失败。
      </para>
    </section>
  </section>
  <section id="understanding-datasets-and-datatables">
    <title>理解 DataSet 和 DataTable</title>
     <para>
      PHPUnit 的数据库扩展模块的核心概念之一就是 DataSet 和 DataTable。为了掌握如何使用 PHPUnit 进行测试，需要试着去了解这些简单的概念。DataSet 和 DataTable 是围绕着数据库表、行、列的抽象层。通过一套简单的API，底层数据库内容被隐藏在对象结构之下，同时，这个对象结构也可以用非数据库数据源来实现。
    </para>
    <para>
      为了能比较实际内容和预期内容，这个抽象是必须的。预期内容可以用诸如 XML、 YAML、 CSV 文件或者 PHP 数组等方式来表达。DataSet 和 DataTable 接口允许对这两个概念上完全不同的数据源进行比较，以语义相似的方法来模拟关系数据库存储。
    </para>
    <para>
      于是，测试中数据库断言的工作流就由以下三个简单的步骤组成：
    </para>
    <itemizedlist>
      <listitem>
        <para>
          用表名称（实际上是数据集）来指定数据库中的一个或多个表。
        </para>
      </listitem>
      <listitem>
        <para>
          用你喜欢的格式（YAML、XML等等）来指定预期数据集。
        </para>
      </listitem>
      <listitem>
        <para>
          断言两个数据集的表示是彼此相等的。
        </para>
      </listitem>
    </itemizedlist>
    <para>
      在 PHPUnit 的数据库扩展中，断言并非唯一使用 DataSet 和 DataTable 的情形。就像上一节中所展示的那样，它们的同样描述了数据库的初始内容。数据库 TestCase 类强制要求定义一个基境数据集，随后用它来：
    </para>
    <itemizedlist>
      <listitem>
        <para>
          从数据集中所指定的表内删除所有行。
        </para>
      </listitem>
      <listitem>
        <para>
          将数据表内的所有行写入数据库。
        </para>
      </listitem>
    </itemizedlist>
    <section id="available-implementations">
      <title>Available Implementations</title>
      <para>
        There are three different types of datasets/datatables:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            File-Based DataSets and DataTables
          </para>
        </listitem>
        <listitem>
          <para>
            Query-Based DataSet and DataTable
          </para>
        </listitem>
        <listitem>
          <para>
            Filter and Composition DataSets and DataTables
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The file-based datasets and tables are generally used for the
        initial fixture and to describe the expected state of the database.
      </para>
      <section id="flat-xml-dataset">
        <title>Flat XML DataSet</title>
        <para>
          The most common dataset is called Flat XML. It is a very simple xml
          format where a tag inside the root node
          <literal>&lt;dataset&gt;</literal> represents exactly one row in the
          database. The tags name equals the table to insert the row into and
          an attribute represents the column. An example for a simple guestbook
          application could look like this:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;nancy&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          This is obviously easy to write. Here
          <literal>&lt;guestbook&gt;</literal> is the table name where two rows
          are inserted into each with four columns <quote>id</quote>,
          <quote>content</quote>, <quote>user</quote> and
          <quote>created</quote> with their respective values.
        </para>
        <para>
          However this simplicity comes at a cost.
        </para>
        <para>
          From the previous example it isn't obvious how you would specify an
          empty table. You can insert a tag with no attributes with the name
          of the empty table. A flat xml file for an empty guestbook table
          would then look like:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          The handling of NULL values with the flat xml dataset is tedious. A
          NULL value is different than an empty string value in almost any
          database (Oracle being an exception), something that is difficult
          to describe in the flat xml format. You can represent a NULL's value
          by omitting the attribute from the row specification. If our
          guestbook would allow anonymous entries represented by a NULL value
          in the user column, a hypothetical state of the guestbook table
          could look like:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          In this case the second entry is posted anonymously. However this
          leads to a serious problem with column recognition. During dataset
          equality assertions each dataset has to specify what columns a
          table holds. If an attribute is NULL for all the rows of a
          data-table, how would the Database Extension know that the column
          should be part of the table?
        </para>
        <para>
          The flat xml dataset makes a crucial assumption now, defining that
          the attributes on the first defined row of a table define the
          columns of this table. In the previous example this would mean
          <quote>id</quote>, <quote>content</quote>, <quote>user</quote> and
          <quote>created</quote> are columns of the guestbook table. For the
          second row where <quote>user</quote> is not defined a NULL would be
          inserted into the database.
        </para>
        <para>
          When the first guestbook entry is deleted from the dataset only
          <quote>id</quote>, <quote>content</quote> and
          <quote>created</quote> would be columns of the guestbook table,
          since <quote>user</quote> is not specified.
        </para>
        <para>
          To use the Flat XML dataset effectively when NULL values are
          relevant the first row of each table must not contain any NULL
          value and only successive rows are allowed to omit attributes. This
          can be awkward, since the order of the rows is a relevant factor
          for database assertions.
        </para>
        <para>
          In turn, if you specify only a subset of the table columns in the
          Flat XML dataset all the omitted values are set to their default
          values. This will lead to errors if one of the omitted columns is
          defined as <quote>NOT NULL DEFAULT NULL</quote>.
        </para>
        <para>
          In conclusion I can only advise using the Flat XML datasets if you
          do not need NULL values.
        </para>
        <para>
          You can create a flat xml dataset instance from within your
          Database TestCase by calling the
          <literal>createFlatXmlDataSet($filename)</literal> method:
        </para>
        <screen>
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
</screen>
      </section>
      <section id="xml-dataset">
        <title>XML DataSet</title>
        <para>
          There is another more structured XML dataset, which is a bit more
          verbose to write but avoids the NULL problems of the Flat XML
          dataset. Inside the root node <literal>&lt;dataset&gt;</literal> you
          can specify <literal>&lt;table&gt;</literal>,
          <literal>&lt;column&gt;</literal>, <literal>&lt;row&gt;</literal>,
          <literal>&lt;value&gt;</literal> and
          <literal>&lt;null /&gt;</literal> tags. An equivalent dataset to the
          previously defined Guestbook Flat XML looks like:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;table name=&quot;guestbook&quot;&gt;
        &lt;column&gt;id&lt;/column&gt;
        &lt;column&gt;content&lt;/column&gt;
        &lt;column&gt;user&lt;/column&gt;
        &lt;column&gt;created&lt;/column&gt;
        &lt;row&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;Hello buddy!&lt;/value&gt;
            &lt;value&gt;joe&lt;/value&gt;
            &lt;value&gt;2010-04-24 17:15:23&lt;/value&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;value&gt;2&lt;/value&gt;
            &lt;value&gt;I like it!&lt;/value&gt;
            &lt;null /&gt;
            &lt;value&gt;2010-04-26 12:14:20&lt;/value&gt;
        &lt;/row&gt;
    &lt;/table&gt;
&lt;/dataset&gt;
</screen>
        <para>
          Any defined <literal>&lt;table&gt;</literal> has a name and requires
          a definition of all the columns with their names. It can contain zero
          or any positive number of nested <literal>&lt;row&gt;</literal>
          elements. Defining no <literal>&lt;row&gt;</literal> element means
          the table is empty. The <literal>&lt;value&gt;</literal> and
          <literal>&lt;null /&gt;</literal> tags have to be specified in the
          order of the previously given <literal>&lt;column&gt;</literal>
          elements. The <literal>&lt;null /&gt;</literal> tag obviously means
          that the value is NULL.
        </para>
        <para>
          You can create a xml dataset instance from within your
          Database TestCase by calling the
          <literal>createXmlDataSet($filename)</literal> method:
        </para>
        <screen>
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this-&gt;createXMLDataSet('myXmlFixture.xml');
    }
}
</screen>
      </section>
      <section id="mysql-xml-dataset">
        <title>MySQL XML DataSet</title>
        <para>
          This new XML format is specific to the
          <ulink url="http://www.mysql.com">MySQL database server</ulink>.
          Support for it was added in PHPUnit 3.5. Files in this format can
          be generated using the
          <ulink url="http://dev.mysql.com/doc/refman/5.0/en/mysqldump.html"><literal>mysqldump</literal></ulink>
          utility. Unlike CSV datasets, which <literal>mysqldump</literal>
          also supports, a single file in this XML format can contain data
          for multiple tables. You can create a file in this format by
          invoking <literal>mysqldump</literal> like so:
        </para>
        <screen>
mysqldump --xml -t -u [username] --password=[password] [database] > /path/to/file.xml
        </screen>
        <para>
          This file can be used in your Database TestCase by calling the
          <literal>createMySQLXMLDataSet($filename)</literal> method:
        </para>
        <screen>
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this-&gt;createMySQLXMLDataSet('/path/to/file.xml');
    }
}
</screen>
      </section>
      <section id="yaml-dataset">
        <title>YAML DataSet</title>
        <para>
          New with PHPUnit 3.4 is the ability to specify a dataset in the
          popular YAML format. For this to work you have to install PHPUnit
          3.4 from PEAR with its optional Symfony YAML dependency. You can
          then write a YAML dataset for the guestbook example:
        </para>
        <screen>
guestbook:
  -
    id: 1
    content: &quot;Hello buddy!&quot;
    user: &quot;joe&quot;
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: &quot;I like it!&quot;
    user:
    created: 2010-04-26 12:14:20
</screen>
        <para>
          This is simple, convient AND it solves the NULL issue that the
          similar Flat XML dataset has. A NULL in YAML is just the column
          name without no value specified. An empty string is specified as
          <literal>column1: &quot;&quot;</literal>.
        </para>
        <para>
          The YAML Dataset has no factory method on the Database TestCase
          currently, so you have to instantiate it manually:
        </para>
        <screen>
require_once &quot;PHPUnit/Extensions/Database/DataSet/YamlDataSet.php&quot;;

class YamlGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return new PHPUnit_Extensions_Database_DataSet_YamlDataSet(
            dirname(__FILE__).&quot;/_files/guestbook.yml&quot;
        );
    }
}
</screen>
      </section>
      <section id="csv-dataset">
        <title>CSV DataSet</title>
        <para>
          Another file-based dataset is based on CSV files. Each table of the
          dataset is represented as a single CSV file. For our guestbook
          example we would define a guestbook-table.csv file:
        </para>
        <screen>
id;content;user;created
1;&quot;Hello buddy!&quot;;&quot;joe&quot;;&quot;2010-04-24 17:15:23&quot;
2;&quot;I like it!&quot;&quot;nancy&quot;;&quot;2010-04-26 12:14:20&quot;
</screen>
        <para>
          While this is very convenient for editing with Excel or OpenOffice,
          you cannot specify NULL values with the CSV dataset. An empty
          column will lead to the database default empty value being inserted
          into the column.
        </para>
        <para>
          You can create a CSV DataSet by calling:
        </para>
        <screen>
require_once 'PHPUnit/Extensions/Database/DataSet/CsvDataSet.php';

class CsvGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_CsvDataSet();
        $dataSet-&gt;addTable('guestbook', dirname(__FILE__).&quot;/_files/guestbook.csv&quot;);
        return $dataSet;
    }
}
</screen>
      </section>
      <section id="array-dataset">
        <title>Array DataSet</title>
        <para>
          There is no Array based DataSet in PHPUnit's Database Extension
          (yet), but we can implement our own easily. Our guestbook example
          should look like:
        </para>
        <screen>
class ArrayGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return new MyApp_DbUnit_ArrayDataSet(array(
            'guestbook' =&gt; array(
                array('id' =&gt; 1, 'content' =&gt; 'Hello buddy!', 'user' =&gt; 'joe', 'created' =&gt; '2010-04-24 17:15:23'),
                array('id' =&gt; 2, 'content' =&gt; 'I like it!',   'user' =&gt; null,  'created' =&gt; '2010-04-26 12:14:20'),
            ),
        ));
    }
}
</screen>
        <para>
          A PHP DataSet has obvious advantages over all the other file-based
          datasets:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              PHP Arrays can obviously handle <literal>NULL</literal> values.
            </para>
          </listitem>
          <listitem>
            <para>
              You won't need additional files for assertions and can specify them
              directly in the TestCase.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          For this dataset like the Flat XML, CSV and YAML DataSets the keys
          of the first specified row define the table's column names, in the
          previous case this would be <quote>id</quote>,
          <quote>content</quote>, <quote>user</quote> and
          <quote>created</quote>.
        </para>
        <para>
          The implementation for this Array DataSet is simple and
          straightforward:
        </para>
        <screen>
require_once 'PHPUnit/Util/Filter.php';

require_once 'PHPUnit/Extensions/Database/DataSet/AbstractDataSet.php';
require_once 'PHPUnit/Extensions/Database/DataSet/DefaultTableIterator.php';
require_once 'PHPUnit/Extensions/Database/DataSet/DefaultTable.php';
require_once 'PHPUnit/Extensions/Database/DataSet/DefaultTableMetaData.php';

PHPUnit_Util_Filter::addFileToFilter(__FILE__, 'PHPUNIT');

class MyApp_DbUnit_ArrayDataSet extends PHPUnit_Extensions_Database_DataSet_AbstractDataSet
{
    /**
     * @var array
     */
    protected $tables = array();

    /**
     * @param array $data
     */
    public function __construct(array $data)
    {
        foreach ($data AS $tableName =&gt; $rows) {
            $columns = array();
            if (isset($rows[0])) {
                $columns = array_keys($rows[0]);
            }

            $metaData = new PHPUnit_Extensions_Database_DataSet_DefaultTableMetaData($tableName, $columns);
            $table = new PHPUnit_Extensions_Database_DataSet_DefaultTable($metaData);

            foreach ($rows AS $row) {
                $table-&gt;addRow($row);
            }
            $this-&gt;tables[$tableName] = $table;
        }
    }

    protected function createIterator($reverse = FALSE)
    {
        return new PHPUnit_Extensions_Database_DataSet_DefaultTableIterator($this-&gt;tables, $reverse);
    }

    public function getTable($tableName)
    {
        if (!isset($this-&gt;tables[$tableName])) {
            throw new InvalidArgumentException(&quot;$tableName is not a table in the current database.&quot;);
        }

        return $this-&gt;tables[$tableName];
    }
}
</screen>
      </section>
      <section id="query-sql-dataset">
        <title>Query (SQL) DataSet</title>
        <para>
          For database assertions you do not only need the file-based datasets
          but also a Query/SQL based Dataset that contains the actual
          contents of the database. This is where the Query DataSet shines:
        </para>
        <screen>
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook');
</screen>
        <para>
          Adding a table just by name is an implicit way to define the
          data-table with the following query:
        </para>
        <screen>
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT * FROM guestbook');
</screen>
        <para>
          You can make use of this by specifying arbitrary queries for your
          tables, for example restricting rows, column or adding
          <literal>ORDER BY</literal> clauses:
        </para>
        <screen>
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
</screen>
        <para>
          The section on Database Assertions will show some more details on
          how to make use of the Query DataSet.
        </para>
      </section>
      <section id="database-db-dataset">
        <title>Database (DB) Dataset</title>
        <para>
          Accessing the Test Connection you can automatically create a
          DataSet that consists of all the tables with their content in the
          database specified as second parameter to the Connections Factory
          method.
        </para>
        <para>
          You can either create a dataset for the complete database as shown
          in <literal>testGuestbook()</literal>, or restrict it to a set of
          specified table names with a whitelist as shown in
          <literal>testFilteredGuestbook()</literal> method.
        </para>
        <screen>
class MySqlGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this-&gt;createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet($tableNames);
        // ...
    }
}
</screen>
      </section>
      <section id="replacement-dataset">
        <title>Replacement DataSet</title>
        <para>
          I have been talking about NULL problems with the Flat XML and CSV
          DataSet, but there is a slightly complicated workaround to get both
          types of datasets working with NULLs.
        </para>
        <para>
          The Replacement DataSet is a decorator for an existing dataset and
          allows you to replace values in any column of the dataset by another
          replacement value. To get our guestbook example working with NULL
          values we specify the file like:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;##NULL##&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          We then wrap the Flat XML DataSet into a Replacement DataSet:
        </para>
        <screen>
require_once 'PHPUnit/Extensions/Database/DataSet/ReplacementDataSet.php';

class ReplacementTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds = $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds-&gt;addFullReplacement('##NULL##', null);
        return $rds;
    }
}
</screen>
      </section>
      <section id="dataset-filter">
        <title>DataSet Filter</title>
        <para>
          If you have a large fixture file you can use the DataSet Filter for
          white- and blacklisting of tables and columns that should be
          contained in a sub-dataset. This is especially handy in combination
          with the DB DataSet to filter the columns of the datasets.
        </para>
        <screen>
class DataSetFilterTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testIncludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addIncludeTables(array('guestbook'));
        $filterDataSet-&gt;setIncludeColumnsForTable('guestbook', array('id', 'content'));
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addExcludeTables(array('foo', 'bar', 'baz')); // only keep the guestbook table!
        $filterDataSet-&gt;setExcludeColumnsForTable('guestbook', array('user', 'created'));
        // ..
    }
}
</screen>
        <blockquote>
          <para>
            <emphasis role="strong">NOTE</emphasis> You cannot use both exclude
            and include column filtering on the same table, only on different
            ones. Plus it is only possible to either white- or blacklist
            tables, not both of them.
          </para>
        </blockquote>
      </section>
      <section id="composite-dataset">
        <title>Composite DataSet</title>
        <para>
          The composite DataSet is very useful for aggregating several
          already existing datasets into a single dataset. When several
          datasets contain the same table the rows are appended in the
          specified order. For example if we have two datasets
          <emphasis>fixture1.xml</emphasis>:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          and <emphasis>fixture2.xml</emphasis>:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;##NULL##&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          Using the Composite DataSet we can aggregate both fixture files:
        </para>
        <screen>
class CompositeTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds1 = $this-&gt;createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this-&gt;createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs-&gt;addDataSet($ds1);
        $compositeDs-&gt;addDataSet($ds2);

        return $compositeDs;
    }
}
</screen>
      </section>
    </section>
    <section id="beware-of-foreign-keys">
      <title>Beware of Foreign Keys</title>
      <para>
        During Fixture SetUp PHPUnit's Database Extension inserts the rows
        into the database in the order they are specified in your fixture.
        If your database schema uses foreign keys this means you have to
        specify the tables in an order that does not cause foreign key
        constraints to fail.
      </para>
    </section>
    <section id="implementing-your-own-datasetsdatatables">
      <title>Implementing your own DataSets/DataTables</title>
      <para>
        To understand the internals of DataSets and DataTables, lets have a
        look at the interface of a DataSet. You can skip this part if you
        do not plan to implement your own DataSet or DataTable.
      </para>
      <screen>
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
</screen>
      <para>
        The public interface is used internally by the
        <literal>assertDataSetsEqual()</literal> assertion on the Database
        TestCase to check for dataset quality. From the
        <literal>IteratorAggregate</literal> interface the IDataSet
        inherits the <literal>getIterator()</literal> method to iterate
        over all tables of the dataset. The additional reverse iterator
        method is required to successfully truncate the tables in reverse
        of the specified order.
      </para>
      <blockquote>
        <para>
          To understand the need for a reverse iterator think of a two tables
          (<emphasis>TableA</emphasis> and <emphasis>TableB</emphasis>) where
          <emphasis>TableB</emphasis> holds a foreign key on a column of
          <emphasis>TableA</emphasis>. If for fixture setup a row is inserted into
          <emphasis>TableA</emphasis> and then a dependant record into
          <emphasis>TableB</emphasis>, then it is obvious that for deleting all the tables
          contents the reverse order run you into trouble with foreign key
          constraints.
        </para>
      </blockquote>
      <para>
        Depending on the implementation different approaches are taken to
        add table instances to a dataset. For example, tables are added
        internally during construction from the source file in all
        file-based datasets such as <literal>YamlDataSet</literal>,
        <literal>XmlDataSet</literal> or <literal>FlatXmlDataSet</literal>.
      </para>
      <para>
        A table is also represented by the following interface:
      </para>
      <screen>
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
</screen>
      <para>
        Except the <literal>getTableMetaData()</literal> method it is
        pretty self-explainatory. The methods are used are all required for
        the different assertions of the Database Extension that are
        explained in the next chapter. The
        <literal>getTableMetaData()</literal> method has to return an
        implementation of the
        <literal>PHPUnit_Extensions_Database_DataSet_ITableMetaData</literal>
        interface, which describes the structure of the table. It holds
        information on:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The table name
          </para>
        </listitem>
        <listitem>
          <para>
            An array of column-names of the table, ordered by their appearance
            in the result-set.
          </para>
        </listitem>
        <listitem>
          <para>
            An array of the primary-key columns.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        This interface also has an assertion that checks if two instances
        of Table Metadata equal each other, which is used by the data-set
        equality assertion.
      </para>
    </section>
  </section>
  <section id="the-connection-api">
    <title>The Connection API</title>
    <para>
      There are three interesting methods on the Connection interface
      which has to be returned from the
      <literal>getConnection()</literal> method on the Database TestCase:
    </para>
    <screen>
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
</screen>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          The <literal>createDataSet()</literal> method creates a Database
          (DB) DataSet as described in the DataSet implementations section.
        </para>
        <screen>
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateDataSet()
    {
        $tableNames = array('guestbook');
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
    }
}
</screen>
      </listitem>
      <listitem>
        <para>
          The <literal>createQueryTable()</literal> method can be used to
          create instances of a QueryTable, give them a result name and SQL
          query. This is a handy method when it comes to result/table
          assertions as will be shown in the next section on the Database
          Assertions API.
        </para>
        <screen>
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateQueryTable()
    {
        $tableNames = array('guestbook');
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable('guestbook', 'SELECT * FROM guestbook');
    }
}
</screen>
      </listitem>
      <listitem>
        <para>
          The <literal>getRowCount()</literal> method is a convienent way to
          access the number of rows in a table, optionally filtered by an
          additional where clause. This can be used with a simple equality
          assertion:
        </para>
        <screen>
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testGetRowCount()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'));
    }
}
</screen>
      </listitem>
    </orderedlist>
  </section>
  <section id="database-assertions-api">
    <title>Database Assertions API</title>
    <para>
      For a testing tool the Database Extension surely provides some
      assertions that you can use to verify the current state ot the
      database, tables and the row-count of tables. This section
      describes this functionality in detail:
    </para>
    <section id="asserting-the-row-count-of-a-table">
      <title>Asserting the Row-Count of a Table</title>
      <para>
        It is often helpful to check if a table contains a specific amount
        of rows. You can easily achieve this without additional glue code
        using the Connection API. Say we wanted to check that after
        insertion of a row into our guestbook we not only have the two
        initial entries that have accompanied us in all the previous
        example, but a third one:
      </para>
      <screen>
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), &quot;Pre-Condition&quot;);

        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry(&quot;suzy&quot;, &quot;Hello world!&quot;);

        $this-&gt;assertEquals(3, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), &quot;Inserting failed&quot;);
    }
}
</screen>
    </section>
    <section id="asserting-the-state-of-a-table">
      <title>Asserting the State of a Table</title>
      <para>
        The previous assertion is helpful, but we surely want to check the
        actual contents of the table to verify that all the values were
        written into the correct columns. This can be achieved by a table
        assertion.
      </para>
      <para>
        For this we would define a Query Table instance which derives its
        content from a table name and SQL query and compare it to a
        File/Array Based Data Set:
      </para>
      <screen>
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry(&quot;suzy&quot;, &quot;Hello world!&quot;);

        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet(&quot;expectedBook.xml&quot;)
                              -&gt;getTable(&quot;guestbook&quot;);
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
</screen>
      <para>
        Now we have to write the <emphasis>expectedBook.xml</emphasis> Flat
        XML file for this assertion:
      </para>
      <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;nancy&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
    &lt;guestbook id=&quot;3&quot; content=&quot;Hello world!&quot; user=&quot;suzy&quot; created=&quot;2010-05-01 21:47:08&quot; /&gt;
&lt;/dataset&gt;
</screen>
      <para>
        This assertion would only pass on exactly one second of the
        universe though, on <emphasis>2010–05–01 21:47:08</emphasis>. Dates
        pose a special problem to database testing and we can circumvent
        the failure by omitting the <quote>created</quote> column from the
        assertion.
      </para>
      <para>
        The adjusted <emphasis>expectedBook.xml</emphasis> Flat XML file
        would probably have to look like the following to make the
        assertion pass:
      </para>
      <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;nancy&quot; /&gt;
    &lt;guestbook id=&quot;3&quot; content=&quot;Hello world!&quot; user=&quot;suzy&quot; /&gt;
&lt;/dataset&gt;
</screen>
      <para>
        We have to fix up the Query Table call:
      </para>
      <screen>
$queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
</screen>
    </section>
    <section id="asserting-the-result-of-a-query">
      <title>Asserting the Result of a Query</title>
      <para>
        You can also assert the result of complex queries with the Query
        Table approach, just specify a result name with a query and
        compare it to a dataset:
      </para>
      <screen>
class ComplexQueryTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testComplexQuery()
    {
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet(&quot;complexQueryAssertion.xml&quot;)
                              -&gt;getTable(&quot;myComplexQuery&quot;);
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
</screen>
    </section>
    <section id="asserting-the-state-of-multiple-tables">
      <title>Asserting the State of Multiple Tables</title>
      <para>
        For sure you can assert the state of multiple tables at once and
        compare a query dataset against a file based dataset. There are two
        different ways for DataSet assertions.
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            You can use the Database (DB) DataSet from the Connection and
            compare it to a File-Based DataSet.
          </para>
          <screen>
class DataSetAssertionsTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateDataSetAssertion()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet(array('guestbook'));
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');
        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
</screen>
        </listitem>
        <listitem>
          <para>
            You can construct the DataSet on your own:
          </para>
          <screen>
class DataSetAssertionsTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testManualDataSetAssertion()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_QueryDataSet();
        $dataSet-&gt;addTable('guestbook', 'SELECT id, content, user FROM guestbook'); // additional tables
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');

        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
</screen>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section id="frequently-asked-questions">
    <title>Frequently Asked Questions</title>
    <section id="will-phpunit-re-create-the-database-schema-for-each-test">
      <title>Will PHPUnit (re-)create the database schema for each
             test?</title>
      <para>
        No, PHPUnit requires all database objects to be available when the
        suite is started. The Database, tables, sequences, triggers and
        views have to be created before you run the test suite.
      </para>
      <para>
        <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> or
        <ulink url="http://www.ezcomponents.org">eZ Components</ulink> have
        powerful tools that allows you to create the database schema from
        pre-defined datastructures, however these have to be hooked into
        the PHPUnit extension to allow automatic database re-creation
        before the complete test-suite is run.
      </para>
      <para>
        Since each test completely cleans the database you are not even
        required to re-create the database for each test-run. A permanently
        available database works perfectly.
      </para>
    </section>
    <section id="am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">
      <title>Am I required to use PDO in my application for the Database
             Extension to work?</title>
      <para>
        No, PDO is only required for the fixture clean- and set-up and for
        assertions. You can use whatever database abstraction you want
        inside your own code.
      </para>
    </section>
    <section id="what-can-i-do-when-i-get-a-too-much-connections-error">
      <title>What can I do, when I get a
             <quote>Too much Connections</quote> Error?</title>
      <para>
        If you do not cache the PDO instance that is created from the
        TestCase <literal>getConnection()</literal> method the number of
        connections to the database is increasing by one or more with each
        database test. With default configuration MySql only allows 100
        concurrent connections other vendors also have maximum connection
        limits.
      </para>
      <para>
        The SubSection
        <quote>Use your own Abstract Database TestCase</quote> shows how
        you can prevent this error from happening by using a single cached
        PDO instance in all your tests.
      </para>
    </section>
    <section id="how-to-handle-null-with-flat-xml-csv-datasets">
      <title>How to handle NULL with Flat XML / CSV Datasets?</title>
      <para>
        Do not do this. Instead, you should use either the XML or the YAML
        DataSets.
      </para>
    </section>
  </section>
</chapter>
