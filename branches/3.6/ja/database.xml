<?xml version="1.0" encoding="utf-8" ?>

<chapter id="database">
  <title>データベースのテスト</title>
  <para>
    初級者・中級者向けのユニットテストのサンプルは、
    どんな言語を対象としたものであっても、
    テストしやすいようなロジックに対してシンプルなテストをしているものばかりです。
    CMS や CRUD、あるいは一般的なデータベースアプリケーションを考えると、
    これはまったく現実離れしています。
    Wordpress や TYPO3、あるいは Symfony で Doctrine/Propel などを使い始めるとすぐに、
    PHPUnit でのテストがやりづらいことを実感するはずです。
    原因は、データベースとこれらのライブラリが密結合になっているからです。
  </para>
  <para>
    きっと日々の業務やプロジェクトでも身に覚えがあることでしょう。
    自分の持つ PHPUnit に関する知識を駆使して作業を進めようとしたのに、
    こんな問題のせいで行き詰ってしまうことが。
  </para>
  <orderedlist numeration="arabic">
    <listitem>
      <para>
        テストしたいメソッドがかなり大きめの join を実行し、
        データを使って重要な結果を算出している。
      </para>
    </listitem>
    <listitem>
      <para>
        ひとつのビジネスロジックの中で select、insert、update そして delete
        を組み合わせて実行している。
      </para>
    </listitem>
    <listitem>
      <para>
        ふたつ以上の (おそらくもっと多い) テーブルから初期データを準備しないと
        そのメソッドのテストができない。
      </para>
    </listitem>
  </orderedlist>
  <para>
    DBUnit Extension を使うと、テスト用のデータベースのセットアップを単純化でき、
    データベース操作後の内容の検証もすることができます。
  </para>
  <section id="supported-vendors-for-database-testing">
    <title>データベースのテストに対応しているベンダー</title>
    <para>
      PHPUnit の Database Extension が現在サポートしているのは、MySQL および
      PostgreSQL、Oracle、SQLite を使ったデータベースのテストです。しかし、
      <ulink url="http://framework.zend.com">Zend Framework</ulink> や
      <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink>
      に組み込まれた Database Extension を使うと、
      IBM DB2 や SQL Server のような他のデータベースにもアクセスできます。
    </para>
  </section>
  <section id="difficulties-in-database-testing">
    <title>データベースのテストの難しさ</title>
    <para>
      ウェブ上にあるユニットテストのサンプルの中にデータベースを扱うものが全く見当たらない理由はなぜか。
      それは、データベースを扱うテストは準備するのも保守するのもたいへんだからです。
      データベースを使うテストをするには、このようなことに気をつける必要があります。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          データベースのスキーマやテーブル
        </para>
      </listitem>
      <listitem>
        <para>
          テーブルへの、テストで必要となるレコードの追加
        </para>
      </listitem>
      <listitem>
        <para>
          テスト実行後のデータベースの状態の検証
        </para>
      </listitem>
      <listitem>
        <para>
          テスト実行ごとのデータベースの後始末
        </para>
      </listitem>
    </itemizedlist>
    <para>
      PDO や ext/mysqli あるいは OCI8 といったデータベース API はどれも使いにくい上に、
      こういった処理を自分で書こうとすると長ったらしくなってしまって面倒です。
    </para>
    <para>
      テストコードはできる限り簡潔に、そして明確に書かねばなりません。その理由は次のとおりです。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          製品コードにちょっと手を加えるたびに大量のテストコードを変更する羽目になるのは困る。
        </para>
      </listitem>
      <listitem>
        <para>
          数ヵ月後に改めて読み直したときにも
          読みやすく理解しやすいテストコードであってほしい。
        </para>
      </listitem>
    </itemizedlist>
    <para>
      さらに知っておく必要があることは、
      データベースは基本的に、自分のコードへのグローバルな入力変数であるということです。
      テストスイート内にあるふたつのテストを同じデータベースに対して実行すると、
      おそらくデータを複数回再利用することになります。あるテストが失敗すると
      それ以降のテストの結果にも影響を及ぼしやすく、テストを進めるのが非常に難しくなります。
      先ほど箇条書きでまとめた中の「後始末」こそが、この
      <quote>データベースがグローバルな入力になる</quote>
      問題を解決するために重要です。
    </para>
    <para>
      PHPUnits の Database Extension を使うと、
      データベースのテストにおけるこれらの問題をシンプルにする助けになります。
    </para>
    <para>
      PHPUnit では助けようにもどうにもならないことが、
      データベースのテストはデータベースを使わないものに比べてとても遅くなるという事実です。
      テストの実行時間がどれくらいになるかはデータベースとのやりとりの量に依存しますが、
      今まで聞いた例ではテストスイートの実行に 40 分かかったということがありました。
      しかし、各テストで使うデータの量を少なめにしておいて
      可能な限りはデータベースを使わないテストで済ませるようにすれば、
      巨大なテストスイートであっても 1 分未満で実行させるのは容易です。
    </para>
    <para>
      <ulink url="http://www.doctrine-project.org">Doctrine 2 プロジェクト</ulink> がよい例です。
      Doctrine 2 は強力なオブジェクト-リレーショナル マッパーを実装しており、
      テストスイートには現時点で約 1000 件のテストが含まれています。
      そのほぼ半数がデータベースを扱うテストですが、
      標準的なデスクトップコンピューター上の MySQL
      を使ってテストスイートを実行しても 15 秒程度でテストが完了します。
    </para>
  </section>
  <section id="the-four-stages-of-a-database-test">
    <title>データベーステストの四段階</title>
    <para>
      Gerard Meszaros は、著書 xUnit Test Patterns でユニットテストを次の四段階に分類しています。
    </para>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          フィクスチャのセットアップ (Setup)
        </para>
      </listitem>
      <listitem>
        <para>
          テストしたいシステムの実行 (Exercise)
        </para>
      </listitem>
      <listitem>
        <para>
          結果の検証 (Verify)
        </para>
      </listitem>
      <listitem>
        <para>
          後始末 (Teardown)
        </para>
      </listitem>
    </orderedlist>
    <blockquote>
      <para>
        <emphasis role="strong">フィクスチャとは?</emphasis>
      </para>
      <para>
        フィクスチャとは、アプリケーションやデータベースの初期状態のことです。
        テストを実行する前に用意します。
      </para>
    </blockquote>
    <para>
      データベースをテストするには、少なくとも setup と teardown
      のときにはテーブルに接続してフィクスチャのクリーンアップや書き込みをしなければなりません。
      しかし、データベース拡張には、
      データベーステストの四段階を次のようなワークフローに振り向ける十分な理由があります。
      このフローは、個々のテストに対して実行します。
    </para>
    <section id="clean-up-database">
      <title>1. データベースのクリーンアップ</title>
      <para>
        データベースを扱う最初のテストというのはいつでも存在します。
        実際のところ、そのときテーブルにデータが存在するのかどうかはわかりません。
        PHPUnit は指定した全テーブルに対して TRUNCATE を実行し、
        テーブルの中身を空にします。
      </para>
    </section>
    <section id="set-up-fixture">
      <title>2. フィクスチャの準備</title>
      <para>
        その後、PHPUnit はフィクスチャの各行を順次処理し、対応するテーブルに書き込みます。
      </para>
    </section>
    <section id="run-test-verify-outcome-and-teardown">
      <title>3–5. テストの実行、結果の検証、そして後始末</title>
      <para>
        データベースをリセットして初期状態を読み込んだら、
        実際のテストを PHPUnit が実行します。
        テストコードのこの部分は Database Extension の存在を知っている必要はなく、
        コードに対してなんでもお好みのテストをすることができます。
      </para>
      <para>
        テストの中で <literal>assertDataSetsEqual()</literal>
        という特殊なアサーションを使って検証しているかもしれません。
        しかし、この機能は完全なオプションです。
        この機能は <quote>データベースアサーション</quote> で説明します。
      </para>
    </section>
  </section>
  <section id="configuration-of-a-phpunit-database-testcase">
    <title>PHPUnit のデータベーステストケースの設定</title>
    <para>
      通常、PHPUnit を使うテストケースでは
      <literal>PHPUnit_Framework_TestCase</literal>
      クラスを継承してこのようにします。
    </para>
    <screen>
require_once &quot;PHPUnit/Framework/TestCase.php&quot;;

class MyTest extends PHPUnit_Framework_TestCase
{
    public function testCalculate()
    {
        $this-&gt;assertEquals(2, 1 + 1);
    }
}
</screen>
    <para>
      テストコードで Database Extension を使う場合は少しだけ複雑になり、
      別の抽象テストケースを継承しなければなりません。そして、二つの抽象メソッド
      <literal>getConnection()</literal> と
      <literal>getDataSet()</literal> を実装します。
    </para>
    <screen>
require_once &quot;PHPUnit/Extensions/Database/TestCase.php&quot;;

class MyGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this-&gt;createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this-&gt;createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
</screen>
    <section id="implementing-getconnection">
      <title><literal>getConnection()</literal> の実装</title>
      <para>
        クリーンアップとフィクスチャの読み込みの機能を動かすには、
        PHPUnit Database Extension からデータベース接続にアクセスできなければなりません。
        データベース接続の抽象化には PDO ライブラリを使います。
        重要なのは、PHPUnit のデータベース拡張を使うためだけに
        わざわざアプリケーションを PDO ベースにする必要はないということです。
        この接続を使うのは、単にクリーンアップとフィクスチャの準備のためだけです。
      </para>
      <para>
        先ほどの例では、インメモリの SQLite 接続を作って
        <literal>createDefaultDBConnection</literal> メソッドに渡しました。
        このメソッドは PDO のインスタンスをラップしたもので、二番目のパラメータ
        (データベース名) に非常にシンプルなデータベース接続の抽象化レイヤーを渡します。このパラメータの型は
        <literal>PHPUnit_Extensions_Database_DB_IDatabaseConnection</literal> です。
      </para>
      <para>
        <quote>データベース接続の使い方</quote>で、このインターフェイスの API
        と、その活用法について説明します。
      </para>
    </section>
    <section id="implementing-getdataset">
      <title><literal>getDataSet()</literal> の実装</title>
      <para>
        <literal>getDataSet()</literal> メソッドで定義するのは、
        個々のテストを実行する前のデータベースの初期状態がどうあるべきかということです。
        データベースの状態の抽象化は DataSet と DataTable
        という概念を使って行い、これらをそれぞれ
        <literal>PHPUnit_Extensions_Database_DataSet_IDataSet</literal> および
        <literal>PHPUnit_Extensions_Database_DataSet_IDataTable</literal>
        というインターフェイスで表します。次の節でこれらの概念を詳しく説明し、
        これをデータベースのテストに使うと何がうれしいのかについても示します。
      </para>
      <para>
        実装するために最低限知っておくべきことは、
        <literal>getDataSet()</literal> メソッドがコールされるのが
        <literal>setUp()</literal> の中で一度だけであり、
        ここでフィクスチャのデータセットを取得してデータベースに挿入するということです。
        先ほどの例では、ファクトリメソッド
        <literal>createFlatXMLDataSet($filename)</literal>
        を使って XML 形式のデータセットを表しました。
      </para>
    </section>
    <section id="what-about-the-datatabase-schema-ddl">
      <title>データベーススキーマ (DDL) とは?</title>
      <para>
        PHPUnit は、テストの実行前にデータベーススキーマ
        (すべてのテーブル、トリガー、シーケンス、ビューを含むもの)
        ができあがっていることを想定しています。つまり開発者としては、
        テストスイートを実行する前にデータベースを正しく準備しておかねばならないということです。
      </para>
      <para>
        データベースのテストにおけるこの事前条件を満たす方法には、次のようなものがあります。
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            インメモリの SQLite ではなく永続化したデータベースを使うのなら、
            最初に一度 phpMyAdmin (MySQL の場合) などのツールでデータベースを用意しておけば、
            あとはテストを実行するたびにそれを再利用できます。
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> や
            <ulink url="http://www.propelorm.org/">Propel</ulink>
            といったライブラリを使っている場合は、その API を使えばテストの実行前に必要なデータベーススキーマを作ることができます。
            <ulink url="http://www.phpunit.de/manual/current/en/textui.html">PHPUnit のブートストラップ</ulink>
            機能を使うと、そのコードをテスト実行時に毎回実行させることもできます。
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="tip:-use-your-own-abstract-database-testcase">
      <title>ヒント: 自前でのデータベーステストケースの抽象化</title>
      <para>
        先の実装例を見ればすぐにわかるでしょうが、
        <literal>getConnection()</literal> メソッドはきわめて静的なものであり、
        さまざまなデータベーステストケースで再利用することができます。
        さらに、テストのパフォーマンスを良好に保ちつつデータベースのオーバーヘッドを下げるために、
        ちょっとしたリファクタリングを施して汎用的な抽象テストケースを用意しましょう。
        このようにしても、テストケースごとに異なるデータフィクスチャを指定することができます。
      </para>
      <screen>
require_once &quot;PHPUnit/Extensions/Database/TestCase.php&quot;;

abstract class MyApp_Tests_DatabaseTestCase extends PHPUnit_Framework_TestCase
{
    // PDO のインスタンス生成は、クリーンアップおよびフィクスチャ読み込みのときに一度だけ
    static private $pdo = null;

    // PHPUnit_Extensions_Database_DB_IDatabaseConnection のインスタンス生成は、テストごとに一度だけ
    private $conn = null;

    final public fucntion getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this-&gt;conn;
    }
}
</screen>
      <para>
        しかし、これはまだデータベースへの接続情報を
        PDO 接続の設定にハードコードしてしまっています。
        PHPUnit にはさらにすばらしい機能があるので、それを使ってテストケースをより汎用的にしましょう。
        <ulink url="http://www.phpunit.de/manual/current/en/appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables">XML 設定ファイル</ulink>
        を使えば、テストの実行のたびにデータベース接続を設定できます。
        まずは <quote>phpunit.xml</quote> というファイルをアプリケーションの tests/ ディレクトリに作り、
        中身をこのようにします。
      </para>
      <screen>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;phpunit&gt;
    &lt;php&gt;
        &lt;var name=&quot;DB_DSN&quot; value=&quot;mysql:dbname=myguestbook;host=localhost&quot; /&gt;
        &lt;var name=&quot;DB_USER&quot; value=&quot;user&quot; /&gt;
        &lt;var name=&quot;DB_PASSWD&quot; value=&quot;passwd&quot; /&gt;
        &lt;var name=&quot;DB_DBNAME&quot; value=&quot;myguestbook&quot; /&gt;
    &lt;/php&gt;
&lt;/phpunit&gt;
</screen>
      <para>
        テストケースはこのように書き直せます。
      </para>
      <screen>
abstract class Generic_Tests_DatabaseTestCase extends PHPUnit_Framework_TestCase
{
    // PDO のインスタンス生成は、クリーンアップおよびフィクスチャ読み込みのときに一度だけ
    static private $pdo = null;

    // PHPUnit_Extensions_Database_DB_IDatabaseConnection のインスタンス生成は、テストごとに一度だけ
    private $conn = null;

    final public fucntion getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this-&gt;conn;
    }
}
</screen>
      <para>
        データベースの設定情報を切り替えてテストスイートを実行するには、
        コマンドラインから次のようにします。
      </para>
      <screen>
user@desktop&gt; phpunit --configuration developer-a.xml MyTests/
user@desktop&gt; phpunit --configuration developer-b.xml MyTests/
</screen>
      <para>
        データベースのテストを実行するときにターゲットデータベースを切り替えられるようにしておくことは、
        開発機で作業をしている場合などは特に重要です。
        複数の開発者が同じデータベース接続を使ってデータベースのテストを実行したりすると、
        レースコンディション (競合条件) によるテストの失敗が頻発するでしょう。
      </para>
    </section>
  </section>
  <section id="understanding-datasets-and-datatables">
    <title>データセットとデータテーブルについて知る</title>
    <para>
      PHPUnit Database Extension の中心となる概念が
      データセットとデータテーブルです。まずはこの考え方を理解することが、
      PHPUnit でのデータベースのテストをマスターする近道です。
      データセットとデータテーブルは、データベースのテーブルや行、
      そしてカラムの抽象化レイヤーです。シンプルな API
      によってデータベースの内容をオブジェクト構造に隠蔽できるだけでなく、
      データベース以外のソースによる実装もできるようになっています。
    </para>
    <para>
      この抽象化を使って、データベースの実際の中身と我々が期待する内容を比較します。
      期待する内容は XML や YAML そして CSV などのファイルでも表せるし、
      PHP の配列として表すこともできます。
      DataSet インターフェイスと DataTable インターフェイスのおかげで、
      これらの全く異なる概念のソースをリレーショナルデータベースに見立てて
      同様に扱えるようになります。
    </para>
    <para>
      データベースのアサーションをテストの中で行う流れは、
      次のようにシンプルな三段階となります。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          ひとつあるいは複数のテーブルをデータベース内から指定する
          (実際のデータセット)。
        </para>
      </listitem>
      <listitem>
        <para>
          期待するデータセットをお好みのフォーマット (YAML, XML など)
          で用意する。
        </para>
      </listitem>
      <listitem>
        <para>
          両者がお互いに等しいことを確認する。
        </para>
      </listitem>
    </itemizedlist>
    <para>
      データセットやデータテーブルの
      PHPUnit Database Extension における使い道は、
      何もアサーションだけだというわけではありません。先ほどの節で見たように、
      これらを使ってデータベースの初期状態の内容を記述することもできます。
      フィクスチャとなるデータセットを Database TestCase
      で定義すると、それをこのように使うことができます。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          データセットで指定したテーブルのすべての行を削除する。
        </para>
      </listitem>
      <listitem>
        <para>
          データテーブルのすべての行をデータベースに書き込む。
        </para>
      </listitem>
    </itemizedlist>
    <section id="available-implementations">
      <title>利用できる実装</title>
      <para>
        これら三種類のデータセット/データテーブルが用意されています。
      </para>
      <itemizedlist>
        <listitem>
          <para>
            ファイルベースのデータセットやデータテーブル
          </para>
        </listitem>
        <listitem>
          <para>
            クエリベースのデータセットやデータテーブル
          </para>
        </listitem>
        <listitem>
          <para>
            フィルタ用や合成用のデータセットやデータテーブル
          </para>
        </listitem>
      </itemizedlist>
      <para>
        ファイルベースのデータセットやデータテーブルは、
        初期状態のフィクスチャを定義したり期待する状態を定義したりするときによく使います。
      </para>
      <section id="flat-xml-dataset">
        <title>フラット XML データセット</title>
        <para>
          最も一般的なデータセットは、フラット XML と呼ばれるものです。
          これは非常にシンプルな xml 形式で、ルートノード
          <literal>&lt;dataset&gt;</literal>
          の中のタグがデータベースのひとつの行を表します。
          テーブルと同じ名前のタグが追加する行を表し、
          その属性がカラムを表します。
          単純な掲示板アプリケーションの例は、このようになります。
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;nancy&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          見るからに書きやすそうですね。この場合は
          <literal>&lt;guestbook&gt;</literal> がテーブル名で、
          2 行が追加されます。そして、四つのカラム <quote>id</quote>、
          <quote>content</quote>、<quote>user</quote> そして
          <quote>created</quote> に、それぞれ対応する値が設定されています。
        </para>
        <para>
          しかし、この単純性による問題もあります。
        </para>
        <para>
          たとえば、先ほどの例で空のテーブルはどうやって指定すればいいのかがよくわかりません。
          実は、何も属性を指定せずにテーブルと同じ名前のタグを追加すれば、空のテーブルを表すことができます。
          空の guestbook テーブルを表すフラット xml ファイルは、このようになります。
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          フラット xml データセットでの NULL 値の処理は、あまりおもしろいものではありません。
          ほとんどのデータベースでは、NULL 値と空文字列は別のものとして扱います
          (例外のひとつは Oracle です) が、これをフラット xml
          形式で表すのは困難です。NULL 値を表すには、
          行の指定のときに属性を省略します。
          この例の掲示板で、匿名の投稿を許可し、そのときには
          user カラムに NULL を指定することにしましょう。
          guestbook テーブルの状態は、このようになります。
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          この例では、二番目のエントリが匿名の投稿を表します。
          しかし、これはカラムの認識において深刻な問題につながります。
          データセットが等しいことを確認するアサーションでは、各データセットでテーブルの持つカラムを指定しなければなりません。
          ある属性がデータテーブルのすべての行で NULL だったなら、
          Database Extension はそのカラムがテーブルに存在することをどうやって知るというのでしょう?
        </para>
        <para>
          フラット XML データセットはここで、重大な前提を使っています。
          テーブルの最初の行で定義されている属性が、そのテーブルのカラムを定義しているものと見なすのです。
          先ほどの例では、guestbook テーブルのカラムが
          <quote>id</quote> と <quote>content</quote>、<quote>user</quote> そして
          <quote>created</quote> であると見なすということです。二番目の行には
          <quote>user</quote> が定義されていないので、データベースには
          NULL を挿入します。
        </para>
        <para>
          guestbook の最初のエントリをデータセットから削除すると、guestbook テーブルのカラムは
          <quote>id</quote>、<quote>content</quote> そして
          <quote>created</quote> だけになってしまいます。
          <quote>user</quote> が指定されていないからです。
        </para>
        <para>
          フラット XML データセットを効率的に使うには、NULL 値がからむ場合は
          各テーブルの最初の行には NULL を含まないようにします。
          それ以降の行では、属性を省略して NULL を表すことができます。
          これはあまりスマートなやり方ではありません。
          というのも、データベースのアサーションで行の順番が影響してしまうからです。
        </para>
        <para>
          一方、テーブルのカラムの一部だけをフラット XML データセットで指定すると、
          それ以外のカラムにはデフォルト値が設定されます。
          そのため、もし省略したカラムの定義が
          <quote>NOT NULL DEFAULT NULL</quote>
          などの場合はエラーになります。
        </para>
        <para>
          結論として言えるのは、フラット XML データセットを使うなら
          NULL 値が不要な場合だけにしておいたほうがよい、ということだけです。
        </para>
        <para>
          フラット XML データセットのインスタンスを
          Database TestCase から作るには、
          <literal>createFlatXmlDataSet($filename)</literal> メソッドを使います。
        </para>
        <screen>
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.yml');
    }
}
</screen>
      </section>
      <section id="xml-dataset">
        <title>XML DataSet</title>
        <para>
          There is another more structured XML dataset, which is a bit more
          verbose to write but avoids the NULL problems of the Flat XML
          dataset. Inside the root node <literal>&lt;dataset&gt;</literal> you
          can specify <literal>&lt;table&gt;</literal>,
          <literal>&lt;column&gt;</literal>, <literal>&lt;row&gt;</literal>,
          <literal>&lt;value&gt;</literal> and
          <literal>&lt;null /&gt;</literal> tags. An equivalent dataset to the
          previously defined Guestbook Flat XML looks like:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;table name=&quot;guestbook&quot;&gt;
        &lt;column&gt;id&lt;/column&gt;
        &lt;column&gt;content&lt;/column&gt;
        &lt;column&gt;user&lt;/column&gt;
        &lt;column&gt;created&lt;/column&gt;
        &lt;row&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;Hello buddy!&lt;/value&gt;
            &lt;value&gt;joe&lt;/value&gt;
            &lt;value&gt;2010-04-24 17:15:23&lt;/value&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;value&gt;2&lt;/value&gt;
            &lt;value&gt;I like it!&lt;/value&gt;
            &lt;null /&gt;
            &lt;value&gt;2010-04-26 12:14:20&lt;/value&gt;
        &lt;/row&gt;
    &lt;/table&gt;
&lt;/dataset&gt;
</screen>
        <para>
          Any defined <literal>&lt;table&gt;</literal> has a name and requires
          a definition of all the columns with their names. It can contain zero
          or any positive number of nested <literal>&lt;row&gt;</literal>
          elements. Defining no <literal>&lt;row&gt;</literal> element means
          the table is empty. The <literal>&lt;value&gt;</literal> and
          <literal>&lt;null /&gt;</literal> tags have to be specified in the
          order of the previously given <literal>&lt;column&gt;</literal>
          elements. The <literal>&lt;null /&gt;</literal> tag obviously means
          that the value is NULL.
        </para>
        <para>
          You can create a flat xml dataset instance from within your
          Database TestCase by calling the
          <literal>createFlatXmlDataSet($filename)</literal> method:
        </para>
        <screen>
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this-&gt;createXMLDataSet('myXmlFixture.yml');
    }
}
</screen>
      </section>
      <section id="yaml-dataset">
        <title>YAML DataSet</title>
        <para>
          New with PHPUnit 3.4 is the ability to specify a dataset in the
          popular YAML format. For this to work you have to install PHPUnit
          3.4 from PEAR with its optional Symfony YAML dependency. You can
          then write a YAML dataset for the guestbook example:
        </para>
        <screen>
guestbook:
  -
    id: 1
    content: &quot;Hello buddy!&quot;
    user: &quot;joe&quot;
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: &quot;I like it!&quot;
    user:
    created: 2010-04-26 12:14:20
</screen>
        <para>
          This is simple, convient AND it solves the NULL issue that the
          similar Flat XML dataset has. A NULL in YAML is just the column
          name without no value specified. An empty string is specified as
          <literal>column1: &quot;&quot;</literal>.
        </para>
        <para>
          The YAML Dataset has no factory method on the Database TestCase
          currently, so you have to instantiate it manually:
        </para>
        <screen>
require_once &quot;PHPUnit/Extensions/Database/DataSet/YamlDataSet.php&quot;;

class YamlGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return new PHPUnit_Extensions_Database_DataSet_YamlDataSet(
            dirname(__FILE__).&quot;/_files/guestbook.yml&quot;
        );
    }
}
</screen>
      </section>
      <section id="csv-dataset">
        <title>CSV DataSet</title>
        <para>
          Another file-based dataset is based on CSV files. Each table of the
          dataset is represented as a single CSV file. For our guestbook
          example we would define a guestbook-table.csv file:
        </para>
        <screen>
id;content;user;created
1;&quot;Hello buddy!&quot;;&quot;joe&quot;;&quot;2010-04-24 17:15:23&quot;
2;&quot;I like it!&quot;&quot;nancy&quot;;&quot;2010-04-26 12:14:20&quot;
</screen>
        <para>
          While this is very convenient for editing with Excel or OpenOffice,
          you cannot specifiy NULL values with the CSV dataset. An empty
          column will lead to the database default empty value being inserted
          into the column.
        </para>
        <para>
          You can create a CSV DataSet by calling:
        </para>
        <screen>
require_once 'PHPUnit/Extensions/Database/DataSet/CsvDataSet.php';

class CsvGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_CsvDataSet();
        $dataSet-&gt;addTable('guestbook', dirname(__FILE__).&quot;/_files/guestbook.csv&quot;);
        return $dataSet;
    }
}
</screen>
      </section>
      <section id="array-dataset">
        <title>Array DataSet</title>
        <para>
          There is no Array based DataSet in PHPUnits Database Extension
          (yet), but we can implement our own easily. Our guestbook example
          should look like:
        </para>
        <screen>
class ArrayGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return new MyApp_DbUnit_ArrayDataSet(array(
            'guestbook' =&gt; array(
                array('id' =&gt; 1, 'content' =&gt; 'Hello buddy!', 'user' =&gt; 'joe', 'created' =&gt; '2010-04-24 17:15:23'),
                array('id' =&gt; 2, 'content' =&gt; 'I like it!',   'user' =&gt; null,  'created' =&gt; '2010-04-26 12:14:20'),
            ),
        ));
    }
}
</screen>
        <para>
          A PHP DataSet has obvious advantages over all the other file-based
          datasets:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              PHP Arrays can obviously handle <literal>NULL</literal> values.
            </para>
          </listitem>
          <listitem>
            <para>
              You won't need additional files for assertions and can specify them
              directly in the TestCase.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          For this dataset like the Flat XML, CSV and YAML DataSets the keys
          of the first specified row defins the tables column names, in the
          previous case this would be <quote>id</quote>,
          <quote>content</quote>, <quote>user</quote> and
          <quote>created</quote>.
        </para>
        <para>
          The implementation for this Array DataSet is simple and
          straightforward:
        </para>
        <screen>
require_once 'PHPUnit/Util/Filter.php';

require_once 'PHPUnit/Extensions/Database/DataSet/AbstractDataSet.php';
require_once 'PHPUnit/Extensions/Database/DataSet/DefaultTableIterator.php';
require_once 'PHPUnit/Extensions/Database/DataSet/DefaultTable.php';
require_once 'PHPUnit/Extensions/Database/DataSet/DefaultTableMetaData.php';

PHPUnit_Util_Filter::addFileToFilter(__FILE__, 'PHPUNIT');

class MyApp_DbUnit_ArrayDataSet extends PHPUnit_Extensions_Database_DataSet_AbstractDataSet
{
    /**
     * @var array
     */
    protected $tables = array();

    /**
     * @param array $data
     */
    public function __construct(array $data)
    {
        foreach ($data AS $tableName =&gt; $rows) {
            $columns = array();
            if (isset($rows[0])) {
                $columns = array_keys($rows[0]);
            }

            $metaData = new PHPUnit_Extensions_Database_DataSet_DefaultTableMetaData($tableName, $columns);
            $table = new PHPUnit_Extensions_Database_DataSet_DefaultTable($metaData);

            foreach ($rows AS $row) {
                $table-&gt;addRow($row);
            }
            $this-&gt;tables[$tableName] = $table;
        }
    }

    protected function createIterator($reverse = FALSE)
    {
        return new PHPUnit_Extensions_Database_DataSet_DefaultTableIterator($this-&gt;tables, $reverse);
    }

    public function getTable($tableName)
    {
        if (!isset($this-&gt;tables[$tableName])) {
            throw new InvalidArgumentException(&quot;$tableName is not a table in the current database.&quot;);
        }

        return $this-&gt;tables[$tableName];
    }
}
</screen>
      </section>
      <section id="query-sql-dataset">
        <title>Query (SQL) DataSet</title>
        <para>
          For database assertions you don't only need the file-based datasets
          but also a Query/SQL based Dataset that contains the actual
          contents of the database. This is where the Query DataSet shines:
        </para>
        <screen>
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook');
</screen>
        <para>
          Adding a table just by name is an implicit way to define the
          data-table with the following query:
        </para>
        <screen>
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT * FROM guestbook');
</screen>
        <para>
          You can make use of this by specifying arbitrary queries for your
          tables, for example restricting rows, column or adding
          <literal>ORDER BY</literal> clauses:
        </para>
        <screen>
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
</screen>
        <para>
          The section on Database Assertions will show some more details on
          how to make use of the Query DataSet.
        </para>
      </section>
      <section id="database-db-dataset">
        <title>Database (DB) Dataset</title>
        <para>
          Accessing the Test Connection you can automatically create a
          DataSet that consists of all the tables with their content in the
          database specified as second parameter to the Connections Factory
          method.
        </para>
        <para>
          You can either create a dataset for the complete database as shown
          in <literal>testGuestbook()</literal>, or restrict it to a set of
          specified table names with a whitelist as shown in
          <literal>testFilteredGuestbook()</literal> method.
        </para>
        <screen>
class MySqlGuestbookTest extends PHPUnit_Framework_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this-&gt;createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet($tableNames);
        // ...
    }
}
</screen>
      </section>
      <section id="replacement-dataset">
        <title>Replacement DataSet</title>
        <para>
          I have been talking about NULL problems with the Flat XML and CSV
          DataSet, but there is a slightly complicated workaround to get both
          types of datasets working with NULLs.
        </para>
        <para>
          The Replacement DataSet is a decorator for an existing dataset and
          allows to replace values in any column of the dataset by another
          replacement value. To get our guestbook example working with NULL
          values we specify the file like:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;##NULL##&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          We then wrap the Flat XML DataSet into a Replacement DataSet:
        </para>
        <screen>
require_once 'PHPUnit/Extensions/Database/DataSet/ReplacementDataSet.php';

class ReplacementTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds = $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.yml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds-&gt;addFullReplacement('##NULL##', null);
        return $rds;
    }
}
</screen>
      </section>
      <section id="dataset-filter">
        <title>DataSet Filter</title>
        <para>
          If you have a large fixture file you can use the DataSet Filter for
          white- and blacklisting of tables and columns that should be
          contained in a sub-dataset. This is especially handy in combination
          with the DB DataSet to filter the columns of the datasets.
        </para>
        <screen>
class DataSetFilterTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testIncludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addIncludeTables(array('guestbook'));
        $filterDataSet-&gt;setIncludeColumnsForTable('guestbook', array('id', 'content'));
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addExcludeTables(array('foo', 'bar', 'baz')); // only keep the guestbook table!
        $filterDataSet-&gt;setExcludeColumnsForTable('guestbook', array('user', 'created));
        // ..
    }
}
</screen>
        <blockquote>
          <para>
            <emphasis role="strong">NOTE</emphasis> You cannot use both exclude
            and include column filtering on the same table, only on different
            ones. Plus it is only possible to either white- or blacklist
            tables, not both of them.
          </para>
        </blockquote>
      </section>
      <section id="composite-dataset">
        <title>Composite DataSet</title>
        <para>
          The composite DataSet is very useful for aggregating several
          already existing datasets into a single dataset. When several
          datasets contain the same table the rows are appended in the
          specified order. For example if we have two datasets
          <emphasis>fixture1.xml</emphasis>:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          and <emphasis>fixture2.xml</emphasis>:
        </para>
        <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;##NULL##&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
&lt;/dataset&gt;
</screen>
        <para>
          Using the Composite DataSet we can aggregate both fixture files:
        </para>
        <screen>
class CompositeTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds1 = $this-&gt;createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this-&gt;createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs-&gt;addDataSet($ds1);
        $compositeDs-&gt;addDataSet($ds2);

        return $compositeDs;
    }
}
</screen>
      </section>
    </section>
    <section id="beware-of-foreign-keys">
      <title>Beware of Foreign Keys</title>
      <para>
        During Fixture SetUp PHPUnits Database Extension inserts the rows
        into the database in the order they are specified in your fixture.
        If your database schema uses foreign keys this means you have to
        specify the tables in an order that does not cause foreign key
        constraints to fail.
      </para>
    </section>
    <section id="implementing-your-own-datasetsdatatables">
      <title>Implementing your own DataSets/DataTables</title>
      <para>
        To understand the internals of DataSets and DataTables, lets have a
        look at the interface of a DataSet. You can skip this part if you
        don't plan to implement your own DataSet or DataTable.
      </para>
      <screen>
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
</screen>
      <para>
        The public interface is used internally by the
        <literal>assertDataSetsEqual()</literal> assertion on the Database
        TestCase to check for dataset quality. From the
        <literal>IteratorAggregate</literal> interface the IDataSet
        inherits the <literal>getIterator()</literal> method to iterate
        over all tables of the dataset. The additional reverse iterator
        method is required to successfully truncate the tables in reverse
        of the specified order.
      </para>
      <blockquote>
        <para>
          To understand the need for a reverse iterator think of a two tables
          (<emphasis>TableA</emphasis> and <emphasis>TableB</emphasis>) where
          <emphasis>TableB</emphasis> holds a foreign key on a column of
          <emphasis>TableA</emphasis>. If for fixture setup a row is inserted
          <emphasis>into TableA</emphasis> and then a dependant record into
          Table B, then it is obvious that for deleting all the tables
          contents the reverse order run you into trouble with foreign key
          constraints.
        </para>
      </blockquote>
      <para>
        Depending on the implementation different approaches are taken to
        add table instances to a dataset. For example, tables are added
        internally during construction from the source file in all
        file-based datasets such as <literal>YamlDataSet</literal>,
        <literal>XmlDataSet</literal> or <literal>FlatXmlDataSet</literal>.
      </para>
      <para>
        A table is also represented by the following interface:
      </para>
      <screen>
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
</screen>
      <para>
        Except the <literal>getTableMetaData()</literal> method it is
        pretty self-explainatory. The methods are used are all required for
        the different assertions of the Database Extension that are
        explained in the next chapter. The
        <literal>getTableMetaData()</literal> method has to return an
        implementation of the
        <literal>PHPUnit_Extensions_Database_DataSet_ITableMetaData</literal>
        interface, which describes the structure of the table. It holds
        information on:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The table name
          </para>
        </listitem>
        <listitem>
          <para>
            An array of column-names of the table, ordered by their appearance
            in the result-set.
          </para>
        </listitem>
        <listitem>
          <para>
            An array of the primary-key columns.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        This interface also has an assertion that checks if two instances
        of Table Metadata equal each other, which is used by the data-set
        equality assertion.
      </para>
    </section>
  </section>
  <section id="the-connection-api">
    <title>The Connection API</title>
    <para>
      There are three interesting methods on the Connection interface
      which has to be returned from the
      <literal>getConnection()</literal> method on the Database TestCase:
    </para>
    <screen>
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
</screen>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          The <literal>createDataSet()</literal> method creates a Database
          (DB) DataSet as described in the DataSet implementations section.
        </para>
        <para>
          class ConnectionTest extends PHPUnit_Extensions_Database_TestCase {
          public function testCreateDataSet() { $tableNames =
          array(<quote>guestbook</quote>); $dataSet =
          $this-&gt;getConnection()-&gt;createDataSet(); } }
        </para>
      </listitem>
      <listitem>
        <para>
          The <literal>createQueryTable()</literal> method can be used to
          create instances of a QueryTable, give them a result name and SQL
          query. This is a handy method when it comes to result/table
          assertions as will be shown in the next section on the Database
          Assertions API.
        </para>
        <para>
          class ConnectionTest extends PHPUnit_Extensions_Database_TestCase {
          public function testCreateQueryTable() { $tableNames =
          array(<quote>guestbook</quote>); $queryTable =
          $this-&gt;getConnection()-&gt;createQueryTable(
          <quote>guestbook</quote>, <quote>SELECT * FROM guestbook</quote> );
          } }
        </para>
      </listitem>
      <listitem>
        <para>
          The <literal>getRowCount()</literal> method is a convienent way to
          access the number of rows in a table, optionally filtered by an
          additional where clause. This can be used with a simple equality
          assertion:
        </para>
        <para>
          class ConnectionTest extends PHPUnit_Extensions_Database_TestCase {
          public function testGetRowCount() { $this-&gt;assertEquals(2,
          $this-&gt;getConnection()-&gt;getRowCount(<quote>guestbook</quote>));
          } }
        </para>
      </listitem>
    </orderedlist>
  </section>
  <section id="database-assertions-api">
    <title>Database Assertions API</title>
    <para>
      For a testing tool the Database Extension surely provides some
      assertions that you can use to verify the current state ot the
      database, tables and the row-count of tables. This section
      describes this functionality in detail:
    </para>
    <section id="asserting-the-row-count-of-a-table">
      <title>Asserting the Row-Count of a Table</title>
      <para>
        It is often helpful to check if a table contains a specific amount
        of rows. You can easily achieve this without additional glue code
        using the Connection API. Say we wanted to check that after
        insertion of a row into our guestbook we not only have the two
        initial entries that have accompanied us in all the previous
        example, but a third one:
      </para>
      <screen>
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), &quot;Pre-Condition&quot;);

        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry(&quot;suzy&quot;, &quot;Hello world!&quot;);

        $this-&gt;assertEquals(3, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), &quot;Inserting failed&quot;);
    }
}
</screen>
    </section>
    <section id="asserting-the-state-of-a-table">
      <title>Asserting the State of a Table</title>
      <para>
        The previous assertion is helpful, but we surely want to check the
        actual contents of the table to verify that all the values were
        written into the correct columns. This can be achieved by a table
        assertion.
      </para>
      <para>
        For this we would define a Query Table instance which derives its
        content from a table name and SQL query and compare it to a
        File/Array Based Data Set:
      </para>
      <screen>
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry(&quot;suzy&quot;, &quot;Hello world!&quot;);

        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet(&quot;expectedBook.xml&quot;)
                              -&gt;getTable(&quot;guestbook&quot;);
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
</screen>
      <para>
        Now we have to write the <emphasis>expectedBook.xml</emphasis> Flat
        XML file for this assertion:
      </para>
      <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; created=&quot;2010-04-24 17:15:23&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;nancy&quot; created=&quot;2010-04-26 12:14:20&quot; /&gt;
    &lt;guestbook id=&quot;3&quot; content=&quot;Hello world!&quot; user=&quot;suzy&quot; created=&quot;2010-05-01 21:47:08&quot; /&gt;
&lt;/dataset&gt;
</screen>
      <para>
        This assertion would only pass on exactly one second of the
        universe though, on <emphasis>2010–05–01 21:47:08</emphasis>. Dates
        pose a special problem to database testing and we can circumvent
        the failure by omitting the <quote>created</quote> column from the
        assertion.
      </para>
      <para>
        The adjusted <emphasis>expectedBook.xml</emphasis> Flat XML file
        would probably have to look like the following to make the
        assertion pass:
      </para>
      <screen>
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;dataset&gt;
    &lt;guestbook id=&quot;1&quot; content=&quot;Hello buddy!&quot; user=&quot;joe&quot; /&gt;
    &lt;guestbook id=&quot;2&quot; content=&quot;I like it!&quot; user=&quot;nancy&quot; /&gt;
    &lt;guestbook id=&quot;3&quot; content=&quot;Hello world!&quot; user=&quot;suzy&quot; /&gt;
&lt;/dataset&gt;
</screen>
      <para>
        We have to fix up the Query Table call:
      </para>
      <screen>
$queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
</screen>
    </section>
    <section id="asserting-the-result-of-a-query">
      <title>Asserting the Result of a Query</title>
      <para>
        You can also assert the result of complex queries with the Query
        Table approach, just specify a a result name with a query and
        compare it to a dataset:
      </para>
      <screen>
class ComplexQueryTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testComplexQuery()
    {
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet(&quot;complexQueryAssertion.xml&quot;)
                              -&gt;getTable(&quot;myComplexQuery&quot;);
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
</screen>
    </section>
    <section id="asserting-the-state-of-multiple-tables">
      <title>Asserting the State of Multiple Tables</title>
      <para>
        For sure you can assert the state of multiple tables at once and
        compare a query dataset against a file based dataset. There are two
        different ways for DataSet assertions.
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            You can use the Database (DB) DataSet from the Connection and
            compare it to a File-Based DataSet.
          </para>
          <para>
            class DataSetAssertionsTest extends
            PHPUnit_Extensions_Database_TestCase { public function
            testCreateDataSetAssertion() { $dataSet =
            $this-&gt;getConnection()-&gt;createDataSet(array(<quote>guestbook</quote>));
            $expectedDataSet =
            $this-&gt;createFlatXmlDataSet(<quote>guestbook.xml</quote>);
          </para>
          <screen>
    $this-&gt;assertDataSetsEqual($exepctedDataSet, $dataSet);
}
</screen>
          <para>
            }
          </para>
        </listitem>
        <listitem>
          <para>
            You can construct the DataSet on your own:
          </para>
          <para>
            class DataSetAssertionsTest extends
            PHPUnit_Extensions_Database_TestCase { public function
            testManualDataSetAssertion() { $dataSet = new
            PHPUnit_Extensions_Database_DataSet_QueryDataSet();
            $dataSet-&gt;addTable(<quote>guestbook</quote>,
            <quote>SELECT id, content, user FROM guestbook</quote>); //
            additional tables
          </para>
          <screen>
    $expectedDataSet = $this-&gt;createFlatXmlDataSet(&quot;guestbook.xml&quot;);

    $this-&gt;assertDataSetsEqual($exepctedDataSet, $dataSet);
}
</screen>
          <para>
            }
          </para>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section id="frequently-asked-questions">
    <title>Frequently Asked Questions</title>
    <section id="will-phpunit-re-create-the-database-schema-for-each-test">
      <title>Will PHPUnit (re-)create the database schema for each
             test?</title>
      <para>
        No, PHPUnit requires all database objects to be available when the
        suite is started. The Database, tables, sequences, triggers and
        views have to be created before you run the testsuite.
      </para>
      <para>
        <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> or
        <ulink url="http://www.ezcomponents.org">eZ Components</ulink> have
        powerful tools that allows you to create the database schema from
        pre-defined datastructures, however these have to be hooked into
        the PHPUnit extension to allow automatic database re-creation
        before the complete test-suite is run.
      </para>
      <para>
        Since each test completely cleans the database you are not even
        required to re-create the database for each test-run. A permanently
        available database works perfectly.
      </para>
    </section>
    <section id="am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">
      <title>Am I required to use PDO in my application for the Database
             Extension to work?</title>
      <para>
        No, PDO is only required for the fixture clean- and set-up and for
        assertions. You can use whatever database abstraction you want
        inside your own code.
      </para>
    </section>
    <section id="what-can-i-do-when-i-get-a-too-much-connections-error">
      <title>What can I do, when I get a
             <quote>Too much Connections</quote> Error?</title>
      <para>
        If you don't cache the PDO instance that is created from the
        TestCase <literal>getConnection()</literal> method the number of
        connections to the database is increasing by one or more with each
        database test. With default configuration MySql only allows 100
        concurrent connections other vendors also have maximum connection
        limits.
      </para>
      <para>
        The SubSection
        <quote>Use your own Abstract Database TestCase</quote> shows how
        you can prevent this error from happening by using a single cached
        PDO instance in all your tests.
      </para>
    </section>
    <section id="how-to-handle-null-with-flat-xml-csv-datasets">
      <title>How to handle NULL with Flat XML / CSV Datasets?</title>
      <para>
        Don't. For this you should use either the XML or the YAML DataSets.
      </para>
    </section>
  </section>
</chapter>

